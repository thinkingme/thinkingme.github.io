"use strict";(self.webpackChunkcoding_road=self.webpackChunkcoding_road||[]).push([[1617],{28372:(e,a,n)=>{n.r(a),n.d(a,{data:()=>t});const t={key:"v-f2d0b44a",path:"/coding-road/java-core/basic-extra-meal/jdk9-char-byte-string.html",title:"jdk9 为何要将 String 的底层实现由 char[]改成了 byte[]?",lang:"zh-CN",frontmatter:{category:["Java核心"],tag:["Java"],summary:"jdk9 为何要将 String 的底层实现由 char[]改成了 byte[]? 大家好，我是二哥呀！如果你不是 Java8 的钉子户，你应该早就发现了：String 类的源码已经由 char[] 优化为了 byte[] 来存储字符串内容，为什么要这样做呢？ 开门见山地说，从 char[] 到 byte[]，最主要的目的是为了节省字符串占用的内存。内存占用",head:[["meta",{property:"og:url",content:"https://vuepress-theme-hope-v2-demo.mrhope.site/coding-road/java-core/basic-extra-meal/jdk9-char-byte-string.html"}],["meta",{property:"og:site_name",content:"coding-rode"}],["meta",{property:"og:title",content:"jdk9 为何要将 String 的底层实现由 char[]改成了 byte[]?"}],["meta",{property:"og:type",content:"article"}],["meta",{property:"og:updated_time",content:"2022-06-04T07:20:53.000Z"}],["meta",{property:"og:locale",content:"zh-CN"}],["meta",{property:"article:tag",content:"Java"}],["meta",{property:"article:modified_time",content:"2022-06-04T07:20:53.000Z"}]]},excerpt:"",headers:[{level:3,title:"一、为什么要优化 String 节省内存空间",slug:"一、为什么要优化-string-节省内存空间",children:[]},{level:3,title:"二、byte[] 为什么就能节省内存空间呢？",slug:"二、byte-为什么就能节省内存空间呢",children:[]},{level:3,title:"三、为什么用 UTF-16 而不用 UTF-8 呢？",slug:"三、为什么用-utf-16-而不用-utf-8-呢",children:[]}],git:{createdTime:1653617096e3,updatedTime:1654327253e3,contributors:[{name:"林振辉",email:"linzhenhui@apexsoft.com",commits:2}]},readingTime:{minutes:4.68,words:1405},filePathRelative:"coding-road/java-core/basic-extra-meal/jdk9-char-byte-string.md"}},46263:(e,a,n)=>{n.r(a),n.d(a,{default:()=>x});var t=n(95393);const r=(0,t.uE)('<h1 id="jdk9-为何要将-string-的底层实现由-char-改成了-byte" tabindex="-1"><a class="header-anchor" href="#jdk9-为何要将-string-的底层实现由-char-改成了-byte" aria-hidden="true">#</a> jdk9 为何要将 String 的底层实现由 char[]改成了 byte[]?</h1><p>大家好，我是二哥呀！如果你不是 Java8 的钉子户，你应该早就发现了：String 类的源码已经由 <code>char[]</code> 优化为了 <code>byte[]</code> 来存储字符串内容，为什么要这样做呢？</p><p>开门见山地说，从 <code>char[]</code> 到 <code>byte[]</code>，最主要的目的是<strong>为了节省字符串占用的内存</strong>。内存占用减少带来的另外一个好处，就是 GC 次数也会减少。</p><h3 id="一、为什么要优化-string-节省内存空间" tabindex="-1"><a class="header-anchor" href="#一、为什么要优化-string-节省内存空间" aria-hidden="true">#</a> 一、为什么要优化 String 节省内存空间</h3><p>我们使用 <code>jmap -histo:live pid | head -n 10</code> 命令就可以查看到堆内对象示例的统计信息、查看 ClassLoader 的信息以及 finalizer 队列。</p><p>以我正在运行着的编程喵喵项目实例（基于 Java 8）来说，结果是这样的。</p><p><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/basic-extra-meal/jdk9-char-byte-string-d826ce88-bbbe-47a3-a1a9-4dd86dd3632f.png" alt="" loading="lazy"></p><p>其中 String 对象有 17638 个，占用了 423312 个字节的内存，排在第三位。</p><p>由于 Java 8 的 String 内部实现仍然是 <code>char[]</code>，所以我们可以看到内存占用排在第 1 位的就是 char 数组。</p><p><code>char[]</code> 对象有 17673 个，占用了 1621352 个字节的内存，排在第一位。</p><p>那也就是说优化 String 节省内存空间是非常有必要的，如果是去优化一个使用频率没有 String 这么高的类库，就显得非常的鸡肋。</p><h3 id="二、byte-为什么就能节省内存空间呢" tabindex="-1"><a class="header-anchor" href="#二、byte-为什么就能节省内存空间呢" aria-hidden="true">#</a> 二、<code>byte[]</code> 为什么就能节省内存空间呢？</h3><p>众所周知，char 类型的数据在 JVM 中是占用两个字节的，并且使用的是 UTF-8 编码，其值范围在 &#39;\\u0000&#39;（0）和 &#39;\\uffff&#39;（65,535）（包含）之间。</p><p>也就是说，使用 <code>char[]</code> 来表示 String 就导致了即使 String 中的字符只用一个字节就能表示，也得占用两个字节。</p><p>而实际开发中，单字节的字符使用频率仍然要高于双字节的。</p><p>当然了，仅仅将 <code>char[]</code> 优化为 <code>byte[]</code> 是不够的，还要配合 Latin-1 的编码方式，该编码方式是用单个字节来表示字符的，这样就比 UTF-8 编码节省了更多的空间。</p><p>换句话说，对于：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">String</span> name <span class="token operator">=</span> <span class="token string">&quot;jack&quot;</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这样的，使用 Latin-1 编码，占用 4 个字节就够了。</p><p>但对于：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">String</span> name <span class="token operator">=</span> <span class="token string">&quot;小二&quot;</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这种，木的办法，只能使用 UTF16 来编码。</p><p>针对 JDK 9 的 String 源码里，为了区别编码方式，追加了一个 coder 字段来区分。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token doc-comment comment">/**\n * The identifier of the encoding used to encode the bytes in\n * <span class="token punctuation">{</span><span class="token keyword">@code</span> <span class="token code-section"><span class="token code language-java">value</span></span><span class="token punctuation">}</span>. The supported values in this implementation are\n *\n * LATIN1\n * UTF16\n *\n * <span class="token keyword">@implNote</span> This field is trusted by the VM, and is a subject to\n * constant folding if String instance is constant. Overwriting this\n * field after construction will cause problems.\n */</span>\n<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">byte</span> coder<span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Java 会根据字符串的内容自动设置为相应的编码，要么 Latin-1 要么 UTF16。</p><p>也就是说，从 <code>char[]</code> 到 <code>byte[]</code>，<strong>中文是两个字节，纯英文是一个字节，在此之前呢，中文是两个字节，应为也是两个字节</strong>。</p><h3 id="三、为什么用-utf-16-而不用-utf-8-呢" tabindex="-1"><a class="header-anchor" href="#三、为什么用-utf-16-而不用-utf-8-呢" aria-hidden="true">#</a> 三、为什么用 UTF-16 而不用 UTF-8 呢？</h3><p>在 UTF-8 中，0-127 号的字符用 1 个字节来表示，使用和 ASCII 相同的编码。只有 128 号及以上的字符才用 2 个、3 个或者 4 个字节来表示。</p><ul><li>如果只有一个字节，那么最高的比特位为 0；</li><li>如果有多个字节，那么第一个字节从最高位开始，连续有几个比特位的值为 1，就使用几个字节编码，剩下的字节均以 10 开头。</li></ul><p>具体的表现形式为：</p><ul><li>0xxxxxxx：一个字节；</li><li>110xxxxx 10xxxxxx：两个字节编码形式（开始两个 1）； - 1110xxxx 10xxxxxx 10xxxxxx：三字节编码形式（开始三个 1）；</li><li>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx：四字节编码形式（开始四个 1）。</li></ul><p>关于字符编码，我在《Java 程序员进阶之路》里曾讲到过，想要深入了解的小伙伴查看下面的链接 🔗：</p>',32),i={href:"https://tobebetterjavaer.com/basic-extra-meal/java-unicode.html",target:"_blank",rel:"noopener noreferrer"},s=(0,t.Uk)("https://tobebetterjavaer.com/basic-extra-meal/java-unicode.html"),c=(0,t._)("p",null,"也就是说，UTF-8 是变长的，那对于 String 这种有随机访问方法的类来说，就很不方便。所谓的随机访问，就是 charAt、subString 这种方法，随便指定一个数字，String 要能给出结果。如果字符串中的每个字符占用的内存是不定长的，那么进行随机访问的时候，就需要从头开始数每个字符的长度，才能找到你想要的字符。",-1),o=(0,t._)("p",null,"那有小伙伴可能会问，UTF-16 也是变长的呢？一个字符还可能占用 4 个字节呢？",-1),l=(0,t._)("p",null,"的确，UTF-16 使用 2 个或者 4 个字节来存储字符。",-1),d=(0,t._)("ul",null,[(0,t._)("li",null,"对于 Unicode 编号范围在 0 ~ FFFF 之间的字符，UTF-16 使用两个字节存储。"),(0,t._)("li",null,"对于 Unicode 编号范围在 10000 ~ 10FFFF 之间的字符，UTF-16 使用四个字节存储，具体来说就是：将字符编号的所有比特位分成两部分，较高的一些比特位用一个值介于 D800~DBFF 之间的双字节存储，较低的一些比特位（剩下的比特位）用一个值介于 DC00~DFFF 之间的双字节存储。")],-1),p=(0,t._)("p",null,"但是在 Java 中，一个字符（char）就是 2 个字节，占 4 个字节的字符，在 Java 里也是用两个 char 来存储的，而 String 的各种操作，都是以 Java 的字符（char）为单位的，charAt 是取得第几个 char，subString 取的也是第几个到第几个 char 组成的子串，甚至 length 返回的都是 char 的个数。",-1),u=(0,t._)("p",null,"所以 UTF-16 在 Java 的世界里，就可以视为一个定长的编码。",-1),h=(0,t.Uk)("参考链接："),g={href:"https://www.zhihu.com/question/447224628",target:"_blank",rel:"noopener noreferrer"},v=(0,t.Uk)("https://www.zhihu.com/question/447224628"),m=(0,t._)("p",null,[(0,t._)("img",{src:"http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/xingbiaogongzhonghao.png",alt:"",loading:"lazy"})],-1),b={},x=(0,n(13860).Z)(b,[["render",function(e,a){const n=(0,t.up)("ExternalLinkIcon");return(0,t.wg)(),(0,t.iD)("div",null,[r,(0,t._)("blockquote",null,[(0,t._)("p",null,[(0,t._)("a",i,[s,(0,t.Wm)(n)])])]),c,o,l,d,p,u,(0,t._)("blockquote",null,[(0,t._)("p",null,[h,(0,t._)("a",g,[v,(0,t.Wm)(n)])])]),m])}]])},13860:(e,a)=>{a.Z=(e,a)=>{const n=e.__vccOpts||e;for(const[e,t]of a)n[e]=t;return n}}}]);