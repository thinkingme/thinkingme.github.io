"use strict";(self.webpackChunkcoding_road=self.webpackChunkcoding_road||[]).push([[5171],{82706:(e,i,l)=>{l.r(i),l.d(i,{data:()=>t});const t={key:"v-43bd2008",path:"/mysql/deletedb-binlog-weiguanjishu.html",title:"",lang:"zh-CN",frontmatter:{summary:"大家好，我是二哥呀~我们都知道，数据非常重要。 网上也经常看到一些段子，某公司程序员对工作不满，删库跑路，老板损失惨重，欲哭无泪。这不前几天又爆出一例，某程序员离职当天删库跑路！ 那么有没有什么解决方案？即使数据库真的被删了，也有备份数据，能快速恢复。甚至可以做到实时热备，即使内部炸掉外部用户也感知不到，一片风平浪静。 MySQL 作为当下流行数据库，在数据",head:[["meta",{property:"og:url",content:"https://vuepress-theme-hope-v2-demo.mrhope.site/mysql/deletedb-binlog-weiguanjishu.html"}],["meta",{property:"og:site_name",content:"coding-rode"}],["meta",{property:"og:type",content:"article"}],["meta",{property:"og:updated_time",content:"2022-06-04T07:20:53.000Z"}],["meta",{property:"og:locale",content:"zh-CN"}],["meta",{property:"article:modified_time",content:"2022-06-04T07:20:53.000Z"}]]},excerpt:"",headers:[{level:3,title:"一、MySQL 主备是什么？",slug:"一、mysql-主备是什么",children:[]},{level:3,title:"二、主从同步",slug:"二、主从同步",children:[]},{level:3,title:"三、开启 binlog",slug:"三、开启-binlog",children:[]},{level:3,title:"四、恢复数据",slug:"四、恢复数据",children:[]}],git:{createdTime:1653617096e3,updatedTime:1654327253e3,contributors:[{name:"林振辉",email:"linzhenhui@apexsoft.com",commits:2}]},readingTime:{minutes:5.97,words:1790},filePathRelative:"mysql/deletedb-binlog-weiguanjishu.md"}},19203:(e,i,l)=>{l.r(i),l.d(i,{default:()=>g});var t=l(95393);const n=(0,t.uE)('<p>大家好，我是二哥呀~我们都知道，数据非常重要。</p><p>网上也经常看到一些段子，某公司程序员对工作不满，删库跑路，老板损失惨重，欲哭无泪。这不前几天又爆出一例，<strong>某程序员离职当天删库跑路</strong>！</p><p><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/mysql/deletedb-binlog-weiguanjishu-1.png" alt="" loading="lazy"></p><p>那么有没有什么解决方案？即使数据库真的被删了，也有备份数据，能快速恢复。甚至可以做到实时热备，即使内部炸掉外部用户也感知不到，一片风平浪静。</p><p><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/mysql/deletedb-binlog-weiguanjishu-2.png" alt="" loading="lazy"></p><p>MySQL 作为当下流行数据库，在数据备份、高可用方面非常有竞争力，今天，我们就重点聊一聊数据备份的杀手锏 binlog。</p><h3 id="一、mysql-主备是什么" tabindex="-1"><a class="header-anchor" href="#一、mysql-主备是什么" aria-hidden="true">#</a> 一、MySQL 主备是什么？</h3><p><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/mysql/deletedb-binlog-weiguanjishu-3.png" alt="" loading="lazy"></p><p>情况一：</p><ul><li>客户端的业务操作，读、写访问的是主库</li><li>主库通过某种机制，将数据实时同步给备库</li><li>主库由于有些原因，无法正常响应客户端的请求</li></ul><p>情况二：</p><ul><li>完成主备切换</li><li>客户端读写，访问的是备库（此时备库升级为新主库）</li></ul><p>那么，这里面最核心的数据同步是如何实现的呢？</p><h3 id="二、主从同步" tabindex="-1"><a class="header-anchor" href="#二、主从同步" aria-hidden="true">#</a> 二、主从同步</h3><p><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/mysql/deletedb-binlog-weiguanjishu-4.png" alt="" loading="lazy"></p><p>1、在备库执行 <code>change master</code> 命令 ，绑定主库的信息</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>mysql&gt; CHANGE MASTER TO MASTER_HOST = &#39;192.168.1.1&#39;, MASTER_USER = &#39;repl&#39;, MASTER_PASSWORD = &#39;replpassword&#39;, MASTER_PORT = 3306, MASTER_AUTO_POSITION = 1, MASTER_RETRY_COUNT = 0, MASTER_HEARTBEAT_PERIOD = 10000;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>简单解释下：</p><ul><li>MASTER_HOST ：master 主机名（或 IP 地址）</li><li>MASTER_PORT ：mysql 实例端口号</li><li>MASTER_USER：用户名</li><li>MASTER_PASSWORD：密码</li><li>MASTER_AUTO_POSITION：如果进行 change master to 时使用 MASTER_AUTO_POSITION = 1，slave 连接 master 将使用基于 GTID 的复制协议</li><li>MASTER_RETRY_COUNT：重连次数</li><li>MASTER_HEARTBEAT_PERIOD：复制心跳的周期</li></ul><p>2、备库执行 start slave 命令，备库启动两个线程：I/O thread 和 SQL thread</p><p>3、master 主库，有数据更新，将此次更新的事件类型写入到主库的 binlog 文件中</p><p>4、主库会创建 log dump 线程，通知 slave 有数据更新</p><p>5、slave，向 master 节点的 log dump 线程请求一份指定 binlog 文件位置的副本，并将请求回来的 binlog 存到本地的 Relay log 中继日志中</p><p>6、slave 再开启一个 SQL 线程读取 Relay log 日志，解析出日志里的命令，并执行，从而保证主备库数据同步</p><h3 id="三、开启-binlog" tabindex="-1"><a class="header-anchor" href="#三、开启-binlog" aria-hidden="true">#</a> 三、开启 binlog</h3><p>从以上步骤可以看得出，binlog 起到了非常关键的作用，那就让我们近距离看下 binlog 日志。</p><p>binlog 格式有三种：</p><ul><li>row</li><li>statement</li><li>mixed</li></ul><p>接下来，我们来做一个实验：</p><p>先创建一个表：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>CREATE TABLE `person` (\n  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;自增主键&#39;,\n  `income` bigint(20) NOT NULL COMMENT &#39;收入&#39;,\n  `expend` bigint(20) NOT NULL COMMENT &#39;支出&#39;,\n  PRIMARY KEY (`id`),\n  KEY `idx_income` (`income`)\n) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 COMMENT=&#39;个人收支表&#39;;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>插入 4 条记录：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>insert into person values(50,500,500);\ninsert into person values(60,600,600);\ninsert into person values(70,700,700);\ninsert into person values(80,800,800);\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>查看 binlog 模式：</p><p><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/mysql/deletedb-binlog-weiguanjishu-5.png" alt="" loading="lazy"></p><p>查看当前正在写入的 binlog 文件：</p><p><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/mysql/deletedb-binlog-weiguanjishu-6.png" alt="" loading="lazy"></p><p>查看 binlog 中的内容，我们先来看下 row 模式</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>show binlog events in &#39;mysql-bin.000001&#39;;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/mysql/deletedb-binlog-weiguanjishu-7.png" alt="" loading="lazy"></p><p>说明：</p><ul><li>SET @@SESSION.GTID_NEXT=&#39;ANONYMOUS’</li><li>BEGIN 开始一个事务</li><li>Table_map 记录更新了哪个库、哪张表</li><li>Write_rows 记录做了什么操作，详细看 binlog 需要借助 mysqlbinlog 工具。</li><li>COMMIT /_ xid=157 _/ 结束一个事务</li></ul><p>查找 binlog 文件的物理位置：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>root@167bfa3785f1:/# find / -name mysql-bin.000001\n/var/lib/mysql/mysql-bin.000001\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>借助 mysqlbinlog 命令，查看具体内容：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>mysqlbinlog -vv mysql-bin.000001 --start-position=2986;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/mysql/deletedb-binlog-weiguanjishu-8.png" alt="" loading="lazy"></p><p>红框中的内容表示执行了插入命令，insert into person values(80,800,800);</p><p>其中，@1、@2、@3 表示表 person 的第几个字段，不用原始名称，是为了节省空间。</p><p><strong>修改 binlog 格式，设置为 STATEMENT</strong> ，查看日志格式：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>set global binlog_format=&#39;STATEMENT&#39;;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>设置之后，需要退出 mysql 重新连接，才能看到生效</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>show binlog events in &#39;mysql-bin.000001&#39;;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/mysql/deletedb-binlog-weiguanjishu-9.png" alt="" loading="lazy"></p><p>从上图中我们可以看出，当 binlog_format=statement 时，binlog 里面记录的就是 SQL 语句的原文。</p><p>其中，use tomge 表示要先切到对应的数据库</p><p>如果想从指定位置查看 binlog，可以增加 from 可选参数，如下：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>show binlog events in &#39;mysql-bin.000001&#39;  from 5168;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>statement 与 row 对比：</p><p>statement 格式的 binlog 记录的是 sql 语句；row 格式的 binlog 记录的是 event（Table_map，Write_rows，Delete_rows）</p><p><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/mysql/deletedb-binlog-weiguanjishu-10.png" alt="" loading="lazy"></p><p>当 binlog 在 statement 格式下，记录的是 sql 语句，在主库执行时可能使用的是索引 A；但是同步给备库执行时，可能用了 索引 B。</p><p>索引不同，同一条 sql 语句，运行结果可能也不一样。</p><p>针对这个场景，我们建议采用 row 格式的 binlog。</p><p>即使我们使用了带 where 条件（如：income&gt;720）的 delete 语句，但 binlog 记录的是要删除的主键 id（id =80 ），所以不会出现差错。</p><p><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/mysql/deletedb-binlog-weiguanjishu-11.png" alt="" loading="lazy"></p><p><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/mysql/deletedb-binlog-weiguanjishu-12.png" alt="" loading="lazy"></p><p><strong>mixed 格式 的 binlog 是个啥</strong>？</p><p>由于 statement 格式的 binlog 可能会导致主库、备库间的数据同步不一致，因此我们会采用 row 格式。</p><p>但是，row 格式占用的空间很大，写 binlog 也要占用大量的 IO 资源。</p><p>所以，官方提出一种 mixed 混合模式，集成了两者的优点。</p><p>内容如下：</p><ul><li>mysql 会自动判断 statement 格式，是否会引发主备不一致的问题</li><li>如果 statement 格式会引起主备不一致的问题，自动使用 row 格式。</li><li>如果 statement 格式不会引起主备不一致的问题，那么就用 statement 格式，</li></ul><h3 id="四、恢复数据" tabindex="-1"><a class="header-anchor" href="#四、恢复数据" aria-hidden="true">#</a> 四、恢复数据</h3><p>当然，我们还建议把 MySQL 的 binlog 设置成 row 模式，因为它可以用于数据恢复。我们来看下 insert、update、delete 三种 DML 操作如何来恢复数据的。</p><p>1、delete：</p><p>当我们执行 delete 命令时，如果 binlog_row_image 设置了 &#39;FULL&#39;，那么 Delete_rows 里面，包含了删掉的行的所有字段的值。</p><p>如果误删了，因为 binlog 记录了所有字段的值，反向执行 insert 就可以了。</p><p>当 binlog_row_image 设置为 MINIMAL，只记录关键信息，比如 id=80 2、insert：</p><p>row 格式下，binlog 会 记录 insert 的所有字段值。</p><p>如果误操作，只需要根据这些值找到对应的行，再执行 delete 操作即可</p><p>3、update：</p><p>row 格式下，binlog 会 记录 update 修改前、修改后的整行数据。</p><p>如果误操作，只需要用修改前的数据覆盖即可。</p><p>通过命令来恢复数据：</p><p>如果要执行数据恢复，可以使用下面命令</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>mysqlbinlog mysql-bin.000001  --start-position=1  --stop-position=3000 | mysql -h192.168.0.1 -P3306 -u$user -p$pwd;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>将 mysql-bin.000001 文件位置从 1 到 3000 的 binlog 在 192.168.0.1 机器的数据库上回放，还原。</p><p>OK，搞定，再也不怕删库跑路了。</p><hr><p>转载自：微观技术</p>',91),a=(0,t.Uk)("转载链接："),s={href:"https://mp.weixin.qq.com/s/oD3Anvz3XCsrahn6WdeeNw",target:"_blank",rel:"noopener noreferrer"},r=(0,t.Uk)("https://mp.weixin.qq.com/s/oD3Anvz3XCsrahn6WdeeNw"),d=(0,t._)("p",null,[(0,t._)("img",{src:"http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/mysql/deletedb-binlog-weiguanjishu-13.png",alt:"",loading:"lazy"})],-1),o=(0,t._)("p",null,[(0,t._)("em",null,"没有什么使我停留——除了目的，纵然岸旁有玫瑰、有绿荫、有宁静的港湾，我是不系之舟"),(0,t.Uk)("。")],-1),p={},g=(0,l(13860).Z)(p,[["render",function(e,i){const l=(0,t.up)("ExternalLinkIcon");return(0,t.wg)(),(0,t.iD)("div",null,[n,(0,t._)("p",null,[a,(0,t._)("a",s,[r,(0,t.Wm)(l)])]),d,o])}]])},13860:(e,i)=>{i.Z=(e,i)=>{const l=e.__vccOpts||e;for(const[e,t]of i)l[e]=t;return l}}}]);