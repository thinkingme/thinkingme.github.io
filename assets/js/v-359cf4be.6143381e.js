"use strict";(self.webpackChunkcoding_road=self.webpackChunkcoding_road||[]).push([[2470],{88054:(a,n,s)=>{s.r(n),s.d(n,{data:()=>e});const e={key:"v-359cf4be",path:"/coding-road/java-core/collection/hashmap-interview.html",title:"Java HashMap 精选面试题",lang:"zh-CN",frontmatter:{category:["求职面试"],tag:["面试题集合"],summary:"Java HashMap 精选面试题 对于 Java 求职者来说，HashMap 可谓是重中之重，是面试的必考点。然而 HashMap 的知识点非常多，复习起来花费精力很大。 01、HashMap 的底层数据结构是什么？ JDK 7 中，HashMap 由“数组+链表”组成，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的。 在 JDK ",head:[["meta",{property:"og:url",content:"https://vuepress-theme-hope-v2-demo.mrhope.site/coding-road/java-core/collection/hashmap-interview.html"}],["meta",{property:"og:site_name",content:"coding-rode"}],["meta",{property:"og:title",content:"Java HashMap 精选面试题"}],["meta",{property:"og:type",content:"article"}],["meta",{property:"og:updated_time",content:"2022-06-04T08:56:49.000Z"}],["meta",{property:"og:locale",content:"zh-CN"}],["meta",{property:"article:tag",content:"面试题集合"}],["meta",{property:"article:modified_time",content:"2022-06-04T08:56:49.000Z"}]]},excerpt:"",headers:[{level:3,title:"01、HashMap 的底层数据结构是什么？",slug:"_01、hashmap-的底层数据结构是什么",children:[]},{level:3,title:"02、为什么链表改为红黑树的阈值是 8?",slug:"_02、为什么链表改为红黑树的阈值是-8",children:[]},{level:3,title:"03、解决 hash 冲突的办法有哪些？HashMap 用的哪种？",slug:"_03、解决-hash-冲突的办法有哪些-hashmap-用的哪种",children:[]},{level:3,title:"04、为什么在解决 hash 冲突的时候，不直接用红黑树？而选择先用链表，再转红黑树?",slug:"_04、为什么在解决-hash-冲突的时候-不直接用红黑树-而选择先用链表-再转红黑树",children:[]},{level:3,title:"05、HashMap 默认加载因子是多少？为什么是 0.75，不是 0.6 或者 0.8 ？",slug:"_05、hashmap-默认加载因子是多少-为什么是-0-75-不是-0-6-或者-0-8",children:[]},{level:3,title:"06、HashMap 中 key 的存储索引是怎么计算的？",slug:"_06、hashmap-中-key-的存储索引是怎么计算的",children:[]},{level:3,title:"07、JDK 8 为什么要 hashcode 异或其右移十六位的值？",slug:"_07、jdk-8-为什么要-hashcode-异或其右移十六位的值",children:[]},{level:3,title:"08、为什么 hash 值要与 length-1 相与？",slug:"_08、为什么-hash-值要与-length-1-相与",children:[]},{level:3,title:"09、HashMap 数组的长度为什么是 2 的幂次方？",slug:"_09、hashmap-数组的长度为什么是-2-的幂次方",children:[]},{level:3,title:"10、HashMap 的 put 方法流程？",slug:"_10、hashmap-的-put-方法流程",children:[]},{level:3,title:"11、HashMap 的扩容方式？",slug:"_11、hashmap-的扩容方式",children:[]},{level:3,title:"12、一般用什么作为 HashMap 的 key?",slug:"_12、一般用什么作为-hashmap-的-key",children:[]},{level:3,title:"13、HashMap 为什么线程不安全？",slug:"_13、hashmap-为什么线程不安全",children:[]}],git:{createdTime:1653617096e3,updatedTime:1654333009e3,contributors:[{name:"林振辉",email:"linzhenhui@apexsoft.com",commits:2},{name:"thinkingme",email:"linzhenhuigg@gmail.com",commits:1}]},readingTime:{minutes:8.52,words:2557},filePathRelative:"coding-road/java-core/collection/hashmap-interview.md"}},90835:(a,n,s)=>{s.r(n),s.d(n,{default:()=>V});var e=s(95393);const t=(0,e.uE)('<h1 id="java-hashmap-精选面试题" tabindex="-1"><a class="header-anchor" href="#java-hashmap-精选面试题" aria-hidden="true">#</a> Java HashMap 精选面试题</h1><p>对于 Java 求职者来说，HashMap 可谓是重中之重，是面试的必考点。然而 HashMap 的知识点非常多，复习起来花费精力很大。</p><h3 id="_01、hashmap-的底层数据结构是什么" tabindex="-1"><a class="header-anchor" href="#_01、hashmap-的底层数据结构是什么" aria-hidden="true">#</a> 01、HashMap 的底层数据结构是什么？</h3><p>JDK 7 中，HashMap 由“数组+链表”组成，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的。</p><p>在 JDK 8 中，HashMap 由“数组+链表+红黑树”组成。链表过长，会严重影响 HashMap 的性能，而红黑树搜索的时间复杂度是 O(logn)，而链表是糟糕的 O(n)。因此，JDK 8 对数据结构做了进一步的优化，引入了红黑树，链表和红黑树在达到一定条件会进行转换：</p><ul><li>当链表超过 8 且数据总量超过 64 时会转红黑树。</li><li>将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树，以减少搜索时间。</li></ul><p>链表长度超过 8 体现在 putVal 方法中的这段代码：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">//链表长度大于8转换为红黑树进行处理</span>\n<span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">&gt;=</span> TREEIFY_THRESHOLD <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// -1 for 1st</span>\n    <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>table 长度为 64 体现在 treeifyBin 方法中的这段代码：：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">treeifyBin</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">,</span> <span class="token keyword">int</span> hash<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">int</span> n<span class="token punctuation">,</span> index<span class="token punctuation">;</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>tab <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">&lt;</span> MIN_TREEIFY_CAPACITY<span class="token punctuation">)</span>\n        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>MIN_TREEIFY_CAPACITY 的值正好为 64。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MIN_TREEIFY_CAPACITY <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>JDK 8 中 HashMap 的结构示意图：</p><p><img src="https://cdn.jsdelivr.net/gh/thinkingme/thinkingme.github.io@master/images/collection/hashmap-interview-01.png" alt="" loading="lazy"></p><h3 id="_02、为什么链表改为红黑树的阈值是-8" tabindex="-1"><a class="header-anchor" href="#_02、为什么链表改为红黑树的阈值是-8" aria-hidden="true">#</a> 02、为什么链表改为红黑树的阈值是 8?</h3><p>因为泊松分布，我们来看作者在源码中的注释：</p>',16),p=(0,e.Uk)("Because TreeNodes are about twice the size of regular nodes, we use them only when bins contain enough nodes to warrant use (see TREEIFY_THRESHOLD). And when they become too small (due to removal or resizing) they are converted back to plain bins. In usages with well-distributed user hashCodes, tree bins are rarely used. Ideally, under random hashCodes, the frequency of nodes in bins follows a Poisson distribution ("),l={href:"http://en.wikipedia.org/wiki/Poisson_distribution",target:"_blank",rel:"noopener noreferrer"},o=(0,e.Uk)("http://en.wikipedia.org/wiki/Poisson_distribution"),i=(0,e.Uk)(") with a parameter of about 0.5 on average for the default resizing threshold of 0.75, although with a large variance because of resizing granularity. Ignoring variance, the expected occurrences of list size k are (exp(-0.5) pow(0.5, k) / factorial(k)). The first values are: 0: 0.60653066"),r=(0,e._)("br",null,null,-1),h=(0,e.Uk)(" 1: 0.30326533"),c=(0,e._)("br",null,null,-1),u=(0,e.Uk)(" 2: 0.07581633"),d=(0,e._)("br",null,null,-1),k=(0,e.Uk)(" 3: 0.01263606"),m=(0,e._)("br",null,null,-1),g=(0,e.Uk)(" 4: 0.00157952"),v=(0,e._)("br",null,null,-1),b=(0,e.Uk)(" 5: 0.00015795"),_=(0,e._)("br",null,null,-1),f=(0,e.Uk)(" 6: 0.00001316"),y=(0,e._)("br",null,null,-1),H=(0,e.Uk)(" 7: 0.00000094"),M=(0,e._)("br",null,null,-1),w=(0,e.Uk)(" 8: 0.00000006"),x=(0,e._)("br",null,null,-1),j=(0,e.Uk)(" more: less than 1 in ten million"),z=(0,e.uE)('<p>翻译过来大概的意思是：理想情况下使用随机的哈希码，容器中节点分布在 hash 桶中的频率遵循泊松分布，按照泊松分布的计算公式计算出了桶中元素个数和概率的对照表，可以看到链表中元素个数为 8 时的概率已经非常小，再多的就更少了，所以原作者在选择链表元素个数时选择了 8，是根据概率统计而选择的。</p><h3 id="_03、解决-hash-冲突的办法有哪些-hashmap-用的哪种" tabindex="-1"><a class="header-anchor" href="#_03、解决-hash-冲突的办法有哪些-hashmap-用的哪种" aria-hidden="true">#</a> 03、解决 hash 冲突的办法有哪些？HashMap 用的哪种？</h3><p>解决 Hash 冲突方法有：</p><ul><li>开放定址法：也称为再散列法，基本思想就是，如果 p=H(key)出现冲突时，则以 p 为基础，再次 hash，p1=H(p),如果 p1 再次出现冲突，则以 p1 为基础，以此类推，直到找到一个不冲突的哈希地址 pi。因此开放定址法所需要的 hash 表的长度要大于等于所需要存放的元素，而且因为存在再次 hash，所以只能在删除的节点上做标记，而不能真正删除节点。</li><li>再哈希法：双重散列，多重散列，提供多个不同的 hash 函数，当 R1=H1(key1)发生冲突时，再计算 R2=H2(key1)，直到没有冲突为止。这样做虽然不易产生堆集，但增加了计算的时间。</li><li>链地址法：拉链法，将哈希值相同的元素构成一个同义词的单链表，并将单链表的头指针存放在哈希表的第 i 个单元中，查找、插入和删除主要在同义词链表中进行。链表法适用于经常进行插入和删除的情况。</li><li>建立公共溢出区：将哈希表分为公共表和溢出表，当溢出发生时，将所有溢出数据统一放到溢出区。</li></ul><p>HashMap 中采用的是链地址法 。</p><h3 id="_04、为什么在解决-hash-冲突的时候-不直接用红黑树-而选择先用链表-再转红黑树" tabindex="-1"><a class="header-anchor" href="#_04、为什么在解决-hash-冲突的时候-不直接用红黑树-而选择先用链表-再转红黑树" aria-hidden="true">#</a> 04、为什么在解决 hash 冲突的时候，不直接用红黑树？而选择先用链表，再转红黑树?</h3><p>因为红黑树需要进行左旋，右旋，变色这些操作来保持平衡，而单链表不需要。</p><p>当元素小于 8 个的时候，此时做查询操作，链表结构已经能保证查询性能。当元素大于 8 个的时候， 红黑树搜索时间复杂度是 O(logn)，而链表是 O(n)，此时需要红黑树来加快查询速度，但是新增节点的效率变慢了。</p><p>因此，如果一开始就用红黑树结构，元素太少，新增效率又比较慢，无疑这是浪费性能的。</p><h3 id="_05、hashmap-默认加载因子是多少-为什么是-0-75-不是-0-6-或者-0-8" tabindex="-1"><a class="header-anchor" href="#_05、hashmap-默认加载因子是多少-为什么是-0-75-不是-0-6-或者-0-8" aria-hidden="true">#</a> 05、HashMap 默认加载因子是多少？为什么是 0.75，不是 0.6 或者 0.8 ？</h3><p>作为一般规则，默认负载因子（0.75）在时间和空间成本上提供了很好的折衷。</p>',11),C={href:"https://mp.weixin.qq.com/s/a3qfatEWizKK1CpYaxVBbA",target:"_blank",rel:"noopener noreferrer"},I=(0,e.Uk)("详情参照这篇"),T=(0,e._)("h3",{id:"_06、hashmap-中-key-的存储索引是怎么计算的",tabindex:"-1"},[(0,e._)("a",{class:"header-anchor",href:"#_06、hashmap-中-key-的存储索引是怎么计算的","aria-hidden":"true"},"#"),(0,e.Uk)(" 06、HashMap 中 key 的存储索引是怎么计算的？")],-1),U=(0,e._)("p",null,"首先根据 key 的值计算出 hashcode 的值，然后根据 hashcode 计算出 hash 值，最后通过 hash&（length-1）计算得到存储的位置。",-1),J={href:"https://mp.weixin.qq.com/s/aS2dg4Dj1Efwujmv-6YTBg",target:"_blank",rel:"noopener noreferrer"},E=(0,e.Uk)("详情参照这篇"),K=(0,e.uE)('<h3 id="_07、jdk-8-为什么要-hashcode-异或其右移十六位的值" tabindex="-1"><a class="header-anchor" href="#_07、jdk-8-为什么要-hashcode-异或其右移十六位的值" aria-hidden="true">#</a> 07、JDK 8 为什么要 hashcode 异或其右移十六位的值？</h3><p>因为在 JDK 7 中扰动了 4 次，计算 hash 值的性能会稍差一点点。</p><p>从速度、功效、质量来考虑，JDK 8 优化了高位运算的算法，通过 hashCode()的高 16 位异或低 16 位实现：<code>(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>。</p><p>这么做可以在数组 table 的 length 比较小的时候，也能保证考虑到高低 Bit 都参与到 Hash 的计算中，同时不会有太大的开销。</p><h3 id="_08、为什么-hash-值要与-length-1-相与" tabindex="-1"><a class="header-anchor" href="#_08、为什么-hash-值要与-length-1-相与" aria-hidden="true">#</a> 08、为什么 hash 值要与 length-1 相与？</h3><ul><li>把 hash 值对数组长度取模运算，模运算的消耗很大，没有位运算快。</li><li>当 length 总是 2 的 n 次方时，<code>h&amp; (length-1) </code>运算等价于对 length 取模，也就是 h%length，但是 &amp; 比 % 具有更高的效率。</li></ul><h3 id="_09、hashmap-数组的长度为什么是-2-的幂次方" tabindex="-1"><a class="header-anchor" href="#_09、hashmap-数组的长度为什么是-2-的幂次方" aria-hidden="true">#</a> 09、HashMap 数组的长度为什么是 2 的幂次方？</h3><p>2 的 N 次幂有助于减少碰撞的几率。如果 length 为 2 的幂次方，则 length-1 转化为二进制必定是 11111……的形式，在与 h 的二进制与操作效率会非常的快，而且空间不浪费。我们来举个例子，看下图：</p><p><img src="https://cdn.jsdelivr.net/gh/thinkingme/thinkingme.github.io@master/images/collection/hashmap-interview-02.png" alt="" loading="lazy"></p><p>当 length =15 时，6 和 7 的结果一样，这样表示他们在 table 存储的位置是相同的，也就是产生了碰撞，6、7 就会在一个位置形成链表，4 和 5 的结果也是一样，这样就会导致查询速度降低。</p><p>如果我们进一步分析，还会发现空间浪费非常大，以 length=15 为例，在 1、3、5、7、9、11、13、15 这八处没有存放数据。因为 hash 值在与 14（即 1110）进行&amp;运算时，得到的结果最后一位永远都是 0，即 0001、0011、0101、0111、1001、1011、1101、1111 位置处是不可能存储数据的。</p><p><strong>再补充数组容量计算的小奥秘。</strong></p><p>HashMap 构造函数允许用户传入的容量不是 2 的 n 次方，因为它可以自动地将传入的容量转换为 2 的 n 次方。会取大于或等于这个数的 且最近的 2 次幂作为 table 数组的初始容量，使用 tableSizeFor(int)方法，如 tableSizeFor(10) = 16（2 的 4 次幂），tableSizeFor(20) = 32（2 的 5 次幂），也就是说 table 数组的长度总是 2 的次幂。JDK 8 源码如下：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span><span class="token keyword">int</span> cap<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">int</span> n <span class="token operator">=</span> cap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>\n        n <span class="token operator">|=</span> n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>\n        n <span class="token operator">|=</span> n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">2</span><span class="token punctuation">;</span>\n        n <span class="token operator">|=</span> n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">4</span><span class="token punctuation">;</span>\n        n <span class="token operator">|=</span> n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">8</span><span class="token punctuation">;</span>\n        n <span class="token operator">|=</span> n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">;</span>\n        <span class="token keyword">return</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token operator">?</span> MAXIMUM_CAPACITY <span class="token operator">:</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>让 cap-1 再赋值给 n 的目的是另找到的目标值大于或等于原值。例如二进制 1000，十进制数值为 8。如果不对它减 1 而直接操作，将得到答案 10000，即 16。显然不是结果。减 1 后二进制为 111，再进行操作则会得到原来的数值 1000，即 8。</p><h3 id="_10、hashmap-的-put-方法流程" tabindex="-1"><a class="header-anchor" href="#_10、hashmap-的-put-方法流程" aria-hidden="true">#</a> 10、HashMap 的 put 方法流程？</h3><p>以 JDK 8 为例，简要流程如下：</p><p>1、首先根据 key 的值计算 hash 值，找到该元素在数组中存储的下标；</p><p>2、如果数组是空的，则调用 resize 进行初始化；</p><p>3、如果没有哈希冲突直接放在对应的数组下标里；</p><p>4、如果冲突了，且 key 已经存在，就覆盖掉 value；</p><p>5、如果冲突后，发现该节点是红黑树，就将这个节点挂在树上；</p><p>6、如果冲突后是链表，判断该链表是否大于 8 ，如果大于 8 并且数组容量小于 64，就进行扩容；如果链表节点大于 8 并且数组的容量大于 64，则将这个结构转换为红黑树；否则，链表插入键值对，若 key 存在，就覆盖掉 value。</p><p><img src="https://cdn.jsdelivr.net/gh/thinkingme/thinkingme.github.io@master/images/collection/hashmap-interview-03.png" alt="" loading="lazy"></p><h3 id="_11、hashmap-的扩容方式" tabindex="-1"><a class="header-anchor" href="#_11、hashmap-的扩容方式" aria-hidden="true">#</a> 11、HashMap 的扩容方式？</h3><p>HashMap 在容量超过负载因子所定义的容量之后，就会扩容。</p>',26),D={href:"https://mp.weixin.qq.com/s/0KSpdBJMfXSVH63XadVdmw",target:"_blank",rel:"noopener noreferrer"},q=(0,e.Uk)("详情参照这篇"),A=(0,e.uE)('<h3 id="_12、一般用什么作为-hashmap-的-key" tabindex="-1"><a class="header-anchor" href="#_12、一般用什么作为-hashmap-的-key" aria-hidden="true">#</a> 12、一般用什么作为 HashMap 的 key?</h3><p>一般用 Integer、String 这种不可变类当作 HashMap 的 key，String 最为常见。</p><ul><li>因为字符串是不可变的，所以在它创建的时候 hashcode 就被缓存了，不需要重新计算。</li><li>因为获取对象的时候要用到 equals() 和 hashCode() 方法，那么键对象正确的重写这两个方法是非常重要的。Integer、String 这些类已经很规范的重写了 hashCode() 以及 equals() 方法。</li></ul><h3 id="_13、hashmap-为什么线程不安全" tabindex="-1"><a class="header-anchor" href="#_13、hashmap-为什么线程不安全" aria-hidden="true">#</a> 13、HashMap 为什么线程不安全？</h3><ul><li>JDK 7 时多线程下扩容会造成死循环。</li><li>多线程的 put 可能导致元素的丢失。</li><li>put 和 get 并发时，可能导致 get 为 null。</li></ul>',5),S={href:"https://mp.weixin.qq.com/s/qk_neCdzM3aB6pVWVTHhNw",target:"_blank",rel:"noopener noreferrer"},Y=(0,e.Uk)("详情参照这篇"),N=(0,e.Uk)("参考链接："),R={href:"https://zhuanlan.zhihu.com/p/362214327",target:"_blank",rel:"noopener noreferrer"},B=(0,e.Uk)("https://zhuanlan.zhihu.com/p/362214327"),F=(0,e._)("p",null,[(0,e._)("img",{src:"https://cdn.jsdelivr.net/gh/thinkingme/thinkingme.github.io@master/images/xingbiaogongzhonghao.png",alt:"",loading:"lazy"})],-1),P={},V=(0,s(13860).Z)(P,[["render",function(a,n){const s=(0,e.up)("ExternalLinkIcon");return(0,e.wg)(),(0,e.iD)("div",null,[t,(0,e._)("blockquote",null,[(0,e._)("p",null,[p,(0,e._)("a",l,[o,(0,e.Wm)(s)]),i,r,h,c,u,d,k,m,g,v,b,_,f,y,H,M,w,x,j])]),z,(0,e._)("p",null,[(0,e._)("a",C,[I,(0,e.Wm)(s)])]),T,U,(0,e._)("p",null,[(0,e._)("a",J,[E,(0,e.Wm)(s)])]),K,(0,e._)("p",null,[(0,e._)("a",D,[q,(0,e.Wm)(s)])]),A,(0,e._)("p",null,[(0,e._)("a",S,[Y,(0,e.Wm)(s)])]),(0,e._)("blockquote",null,[(0,e._)("p",null,[N,(0,e._)("a",R,[B,(0,e.Wm)(s)])])]),F])}]])},13860:(a,n)=>{n.Z=(a,n)=>{const s=a.__vccOpts||a;for(const[a,e]of n)s[a]=e;return s}}}]);