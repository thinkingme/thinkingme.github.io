"use strict";(self.webpackChunkcoding_road=self.webpackChunkcoding_road||[]).push([[9997],{73361:(e,a,n)=>{n.r(a),n.d(a,{data:()=>t});const t={key:"v-6d4ea801",path:"/coding-road/javaee/cloud/netflix/eureka.html",title:"Eureka 原理",lang:"zh-CN",frontmatter:{summary:"Eureka 原理 一、服务注册发现简要流程 首先通过以下一幅图简单看下 eureka 的服务注册发现流程是什么样的： 1、服务提供者提供应用服务，注册到 eureka server 中。 2、服务消费者每 30 秒去去注册中心拉取服务的 ip，端口，接口地址等信息。 3、服务消费者拉取到服务提供者的应用信息后，可以直接去调用服务提供者的接口。 二、服务发现",head:[["meta",{property:"og:url",content:"https://vuepress-theme-hope-v2-demo.mrhope.site/coding-road/javaee/cloud/netflix/eureka.html"}],["meta",{property:"og:site_name",content:"coding-rode"}],["meta",{property:"og:title",content:"Eureka 原理"}],["meta",{property:"og:type",content:"article"}],["meta",{property:"og:updated_time",content:"2022-06-04T07:20:53.000Z"}],["meta",{property:"og:locale",content:"zh-CN"}],["meta",{property:"article:modified_time",content:"2022-06-04T07:20:53.000Z"}]]},excerpt:"",headers:[{level:2,title:"服务注册",slug:"服务注册",children:[]},{level:2,title:"服务续约",slug:"服务续约",children:[]},{level:2,title:"服务获取",slug:"服务获取",children:[{level:3,title:"缓存未命中",slug:"缓存未命中",children:[]}]},{level:2,title:"服务调用",slug:"服务调用",children:[]},{level:2,title:"服务下线",slug:"服务下线",children:[]},{level:2,title:"失效剔除",slug:"失效剔除",children:[]},{level:2,title:"自我保护",slug:"自我保护",children:[]},{level:2,title:"eureka 宕机后，服务之间仍然可以通信。",slug:"eureka-宕机后-服务之间仍然可以通信。",children:[]},{level:2,title:"集群注册信息同步",slug:"集群注册信息同步",children:[]},{level:2,title:"eureka 保证 CAP 中的 AP",slug:"eureka-保证-cap-中的-ap",children:[]}],git:{createdTime:1654327253e3,updatedTime:1654327253e3,contributors:[{name:"林振辉",email:"linzhenhui@apexsoft.com",commits:1}]},readingTime:{minutes:5.75,words:1726},filePathRelative:"coding-road/javaee/cloud/netflix/eureka.md"}},16428:(e,a,n)=>{n.r(a),n.d(a,{default:()=>d});var t=n(95393);const s=(0,t.uE)('<h1 id="eureka-原理" tabindex="-1"><a class="header-anchor" href="#eureka-原理" aria-hidden="true">#</a> Eureka 原理</h1><h1 id="一、服务注册发现简要流程" tabindex="-1"><a class="header-anchor" href="#一、服务注册发现简要流程" aria-hidden="true">#</a> 一、服务注册发现简要流程</h1><p>首先通过以下一幅图简单看下 eureka 的服务注册发现流程是什么样的：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b449c75cfeaa4d1c8fe7987171fa7d33~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?" alt="image.png" loading="lazy"></p><p>1、服务提供者提供应用服务，注册到 eureka server 中。</p><p>2、服务消费者每 30 秒去去注册中心拉取服务的 ip，端口，接口地址等信息。</p><p>3、服务消费者拉取到服务提供者的应用信息后，可以直接去调用服务提供者的接口。</p><h1 id="二、服务发现注册的整体流程" tabindex="-1"><a class="header-anchor" href="#二、服务发现注册的整体流程" aria-hidden="true">#</a> 二、服务发现注册的整体流程</h1><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e42bd810ea96421197f4a3fd1db51fa5~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?" alt="image.png" loading="lazy"></p><h1 id="三、主要概念及原理" tabindex="-1"><a class="header-anchor" href="#三、主要概念及原理" aria-hidden="true">#</a> 三、主要概念及原理</h1><h2 id="服务注册" tabindex="-1"><a class="header-anchor" href="#服务注册" aria-hidden="true">#</a> 服务注册</h2><p>服务注册的原理主要涉及到 eureka server 的存储结构，采用一个三层缓存的结构。具体内部的实现逻辑参考二中的图。</p><table><thead><tr><th>层级</th><th>名称</th><th>实现方式</th><th>更新方式</th><th>数据变更</th></tr></thead><tbody><tr><td>第一层</td><td>readOnlyCacheMap（只读）</td><td>ConcurrentHashMap</td><td>定时更新（默认 30s）</td><td>定时拉取 readWriteCacheMap</td></tr><tr><td>第二层</td><td>readWriteCacheMap（读写）</td><td>guava</td><td>实时更新</td><td>guava 的 load 机制</td></tr><tr><td>第三层</td><td>register（注册表）</td><td>双层 ConcurrentHashMap</td><td>实时更新</td><td>客户端的注册、续约、下线</td></tr></tbody></table><h2 id="服务续约" tabindex="-1"><a class="header-anchor" href="#服务续约" aria-hidden="true">#</a> 服务续约</h2><p>当服务提供者完成服务信息注册后，会维持一个心跳，定时向 eureka server 发送 rest 请求，告诉其还活着。默认心跳间隔 30s。</p><h2 id="服务获取" tabindex="-1"><a class="header-anchor" href="#服务获取" aria-hidden="true">#</a> 服务获取</h2><p>eureka client 会定期（默认 30s）向 eureka server 获取获取注册的服务信息，这个获取分为<code>全量获取</code>和<code>增量获取</code>。</p><p>默认配置下，当客户端首次启动后，会向服务端发起一次全量获取并缓存本地信息，之后每隔 30s 发起一次增量获取，更新本地缓存。</p><h3 id="缓存未命中" tabindex="-1"><a class="header-anchor" href="#缓存未命中" aria-hidden="true">#</a> 缓存未命中</h3><p>缓存未命中会调用 guava 的 loal 机制执行方法。</p><ul><li>服务端</li></ul><p>代码：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token class-name">Value</span> <span class="token function">generatePayload</span><span class="token punctuation">(</span><span class="token class-name">Key</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">//全量获取</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>ALL_APPS<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            payload <span class="token operator">=</span> <span class="token function">getPayLoad</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> registry<span class="token punctuation">.</span><span class="token function">getApplicationsFromMultipleRegions</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">getRegions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token comment">//增量获取</span>\n    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ALL_APPS_DELTA<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            payload <span class="token operator">=</span> <span class="token function">getPayLoad</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>registry<span class="token punctuation">.</span><span class="token function">getApplicationDeltasFromMultipleRegions</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">getRegions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>区别：</p><ol><li>增量获取是从 recentlyChangedQueue 这样一个队列中获取的。这个队列在进行注册时会往其中加入数据。这个队列只会保留最近注册的服务信息。</li></ol><div class="language-JAVA ext-JAVA line-numbers-mode"><pre class="language-JAVA"><code>//recentlyChangedQueue定时过期代码，使用java.util.TimerTask\nprivate TimerTask getDeltaRetentionTask() {\n    return new TimerTask() {\n        @Override\n        public void run() {\n            Iterator&lt;RecentlyChangedItem&gt; it = recentlyChangedQueue.iterator();\n            while (it.hasNext()) {\n                if (it.next().getLastUpdateTime() &lt;\n                    System.currentTimeMillis() - serverConfig.getRetentionTimeInMSInDeltaQueue()) {\n                    it.remove();\n                } else {\n                    break;\n                }\n            }\n        }\n\n    };\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>全量获取是直接从 register（注册表）中获取全部信息</li></ol><h2 id="服务调用" tabindex="-1"><a class="header-anchor" href="#服务调用" aria-hidden="true">#</a> 服务调用</h2><p>通常服务间调用使用组件 feign，发起 rest 请求；</p><p>其内集成了 ribbon，ribbon 默认使用了轮询的负载策略，会将 eureka client 拉取的注册信息拉取到自己这，实现负载。</p><h2 id="服务下线" tabindex="-1"><a class="header-anchor" href="#服务下线" aria-hidden="true">#</a> 服务下线</h2><p>表示要从注册中心删除该服务的注册信息，使该服务不能被调用。</p><p>服务下线的方式：</p><table><thead><tr><th>方式</th><th>实现</th><th>效果</th></tr></thead><tbody><tr><td>直接停服务</td><td>直接 kill 服务</td><td>90s 内注册中心检测到服务无续约，才删除，无法立即下线</td></tr><tr><td>通过注册中心接口强制下线</td><td>向 eureka 注册中心发送 delete</td><td>默认 30s 的心跳机制，如果在这段时间没有停掉服务，那么会让该服务再次上线</td></tr><tr><td>客户端主动下线</td><td>@GetMapping(&quot;/offline&quot;) public void offline(){ DiscoveryManager.getInstance().shutdownComponent(); }</td><td>优雅的下线服务</td></tr></tbody></table><h2 id="失效剔除" tabindex="-1"><a class="header-anchor" href="#失效剔除" aria-hidden="true">#</a> 失效剔除</h2><p>在 eureka server 中有一个定时任务 Evict，该任务默认每 60s 执行一次，其作用域在 readWriteCacheMap 和 register 上。</p><p>当有服务提供者在默认 90s 时间内，没有进行服务续约，当 Evict 执行时，会对这样失效的注册信息进行剔除。通常是宕机的服务或者强制 kill 的服务。</p><h2 id="自我保护" tabindex="-1"><a class="header-anchor" href="#自我保护" aria-hidden="true">#</a> 自我保护</h2><p><strong>官方定义</strong>：自我保护模式正是一种针对网络异常波动的安全保护措施，使用自我保护模式能使 Eureka 集群更加的健壮、稳定的运行。</p><p>Eureka Server 在运行期间会统计心跳失败的比例在 15 分钟内是否低于 85%，如果出现低于的情况，Eureka Server 会将当前的实例注册信息保护起来，不会让它们立刻过期。</p><p>此配置在默认环境下开启。</p><p><strong>自我保护存在的问题</strong>：在保护期间，服务挂掉，导致服务无法下线，造成调用接口失败。</p><h2 id="eureka-宕机后-服务之间仍然可以通信。" tabindex="-1"><a class="header-anchor" href="#eureka-宕机后-服务之间仍然可以通信。" aria-hidden="true">#</a> eureka 宕机后，服务之间仍然可以通信。</h2><p>因为 eureka client 本地缓存注册表信息，当 eureka server 宕机后服务间仍然可以访问，但是服务提供端和服务消费端又分为以下情况：</p><ul><li>当服务消费端重启后，本地缓存失效，与服务提供端的映射不存在了，无法进行服务调用。</li><li>当服务提供端重启后，在服务调用端的本地缓存中，仍然保存有在 eureka 宕机前的缓存信息，可以正常调用服务。</li></ul><h2 id="集群注册信息同步" tabindex="-1"><a class="header-anchor" href="#集群注册信息同步" aria-hidden="true">#</a> 集群注册信息同步</h2><ul><li><p>eureka 采用的同步方式是<code>peer to peer（对等复制）</code>，副本间不分主从，任何副本都可以接收写操作，然后每个副本间互相进行数据更新。</p></li><li><p>Eureka Server 本身依赖了 Eureka Client，也就是每个 Eureka Server 是作为其他 Eureka Server 的 Client。</p></li><li><p>Eureka Server 启动后，会通过 Eureka Client 请求其他 Eureka Server 节点中的一个节点，获取注册的服务信息，然后复制到其他 peer 节点。</p></li><li><p>Eureka Server 每当自己的信息变更后，例如 Client 向自己发起注册、续约、注销请求， 就会把自己的最新信息通知给其他 Eureka Server，保持数据同步。</p></li><li><p>存在的问题：</p><ul><li>（1）每个节点都可以进行写操作，会导致数据冲突。</li><li>（2）如果自己的信息变更是另一个 Eureka Server 同步过来的，这是再同步回去的话就出现数据同步死循环了。</li></ul></li><li><p>问题（1）解决方案：</p><p>Eureka 是通过 lastDirtyTimestamp 这个类似版本号的属性来解决该问题。 lastDirtyTimestamp 是注册中心里面服务实例的一个属性，表示此服务实例最近一次变更时间。</p></li><li><p>问题（2）解决方案：</p><p>Eureka Server 在执行复制操作的时候，使用 HEADER_REPLICATION，参数名 isReplication， （eureka-core-1.10.17：ApplicationResource 类下 addInstance 方法）这个 http header 来区分普通应用实例的正常请求，说明这是一个复制请求，这样其他 peer 节点收到请求时，就不会再对其进行复制操作，从而避免死循环。</p></li></ul><h2 id="eureka-保证-cap-中的-ap" tabindex="-1"><a class="header-anchor" href="#eureka-保证-cap-中的-ap" aria-hidden="true">#</a> eureka 保证 CAP 中的 AP</h2><p>通过前面了解到，eureka 并没有保证数据的强一致性，只保证了数据的<strong>最终一致性</strong>，通过集群模式保证了<strong>高可用</strong>。</p>',49),i=(0,t.Uk)("作者：我犟不过你 链接："),r={href:"https://juejin.cn/post/7057699861868576799",target:"_blank",rel:"noopener noreferrer"},p=(0,t.Uk)("https://juejin.cn/post/7057699861868576799"),l=(0,t.Uk)(" 来源：稀土掘金 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"),c={},d=(0,n(13860).Z)(c,[["render",function(e,a){const n=(0,t.up)("ExternalLinkIcon");return(0,t.wg)(),(0,t.iD)("div",null,[s,(0,t._)("p",null,[i,(0,t._)("a",r,[p,(0,t.Wm)(n)]),l])])}]])},13860:(e,a)=>{a.Z=(e,a)=>{const n=e.__vccOpts||e;for(const[e,t]of a)n[e]=t;return n}}}]);