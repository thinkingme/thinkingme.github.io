"use strict";(self.webpackChunkcoding_road=self.webpackChunkcoding_road||[]).push([[8581],{72564:(n,s,a)=>{a.r(s),a.d(s,{data:()=>t});const t={key:"v-47fdfb72",path:"/coding-road/java-core/collection/hashmap.html",title:"Java8 系列之重新认识 HashMap",lang:"zh-CN",frontmatter:{category:["Java核心"],tag:["Java"],summary:"Java8 系列之重新认识 HashMap 一、hash 方法的原理 来看一下 hash 方法的源码（JDK 8 中的 HashMap）： 这段代码究竟是用来干嘛的呢？ 我们都知道，key.hashCode() 是用来获取键位的哈希值的，理论上，哈希值是一个 int 类型，范围从-2147483648 到 2147483648。前后加起来大概 40 亿的映射",head:[["meta",{property:"og:url",content:"https://vuepress-theme-hope-v2-demo.mrhope.site/coding-road/java-core/collection/hashmap.html"}],["meta",{property:"og:site_name",content:"coding-rode"}],["meta",{property:"og:title",content:"Java8 系列之重新认识 HashMap"}],["meta",{property:"og:type",content:"article"}],["meta",{property:"og:updated_time",content:"2022-06-04T08:56:49.000Z"}],["meta",{property:"og:locale",content:"zh-CN"}],["meta",{property:"article:tag",content:"Java"}],["meta",{property:"article:modified_time",content:"2022-06-04T08:56:49.000Z"}]]},excerpt:"",headers:[{level:2,title:"一、hash 方法的原理",slug:"一、hash-方法的原理",children:[]},{level:2,title:"二、扩容机制",slug:"二、扩容机制",children:[]},{level:2,title:"三、加载因子为什么是 0.75",slug:"三、加载因子为什么是-0-75",children:[]},{level:2,title:"四、线程不安全",slug:"四、线程不安全",children:[{level:3,title:"01、多线程下扩容会死循环",slug:"_01、多线程下扩容会死循环",children:[]},{level:3,title:"02、多线程下 put 会导致元素丢失",slug:"_02、多线程下-put-会导致元素丢失",children:[]},{level:3,title:"03、put 和 get 并发时会导致 get 到 null",slug:"_03、put-和-get-并发时会导致-get-到-null",children:[]}]}],git:{createdTime:1653617096e3,updatedTime:1654333009e3,contributors:[{name:"林振辉",email:"linzhenhui@apexsoft.com",commits:2},{name:"thinkingme",email:"linzhenhuigg@gmail.com",commits:1}]},readingTime:{minutes:23.18,words:6953},filePathRelative:"coding-road/java-core/collection/hashmap.md"}},12046:(n,s,a)=>{a.r(s),a.d(s,{default:()=>bn});var t=a(95393);const p=(0,t.uE)('<h1 id="java8-系列之重新认识-hashmap" tabindex="-1"><a class="header-anchor" href="#java8-系列之重新认识-hashmap" aria-hidden="true">#</a> Java8 系列之重新认识 HashMap</h1><h2 id="一、hash-方法的原理" tabindex="-1"><a class="header-anchor" href="#一、hash-方法的原理" aria-hidden="true">#</a> 一、hash 方法的原理</h2><p>来看一下 hash 方法的源码（JDK 8 中的 HashMap）：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">int</span> h<span class="token punctuation">;</span>\n    <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码究竟是用来干嘛的呢？</p><p>我们都知道，<code>key.hashCode()</code> 是用来获取键位的哈希值的，理论上，哈希值是一个 int 类型，范围从-2147483648 到 2147483648。前后加起来大概 40 亿的映射空间，只要哈希值映射得比较均匀松散，一般是不会出现哈希碰撞的。</p><p>但问题是一个 40 亿长度的数组，内存是放不下的。HashMap 扩容之前的数组初始大小只有 16，所以这个哈希值是不能直接拿来用的，用之前要和数组的长度做取模运算，用得到的余数来访问数组下标才行。</p><p>取模运算有两处。</p><blockquote><p>取模运算（“Modulo Operation”）和取余运算（“Remainder Operation ”）两个概念有重叠的部分但又不完全一致。主要的区别在于对负整数进行除法运算时操作不同。取模主要是用于计算机术语中，取余则更多是数学概念。</p></blockquote><p>一处是往 HashMap 中 put 的时候（<code>putVal</code> 方法中）：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span> <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n     <span class="token class-name">HashMap<span class="token punctuation">.</span>Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token class-name">HashMap<span class="token punctuation">.</span>Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">;</span>\n     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>\n         n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>\n     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>\n         tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一处是从 HashMap 中 get 的时候（<code>getNode</code> 方法中）：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n     <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> first<span class="token punctuation">,</span> e<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span> <span class="token class-name">K</span> k<span class="token punctuation">;</span>\n     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>\n            <span class="token punctuation">(</span>first <span class="token operator">=</span> tab<span class="token punctuation">[</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中的 <code>(n - 1) &amp; hash</code> 正是取模运算，就是把哈希值和（数组长度-1）做了一个“与”运算。</p><p>可能大家在疑惑：<strong>取模运算难道不该用 <code>%</code> 吗？为什么要用 <code>&amp;</code> 呢</strong>？</p><p>这是因为 <code>&amp;</code> 运算比 <code>%</code> 更加高效，并且当 b 为 2 的 n 次方时，存在下面这样一个公式。</p><blockquote><p>a % b = a &amp; (b-1)</p></blockquote>',17),e=(0,t._)("p",null,[(0,t.Uk)("用 "),(0,t._)("span",{class:"katex"},[(0,t._)("span",{class:"katex-mathml"},[(0,t._)("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[(0,t._)("semantics",null,[(0,t._)("mrow",null,[(0,t._)("msup",null,[(0,t._)("mn",null,"2"),(0,t._)("mi",null,"n")])]),(0,t._)("annotation",{encoding:"application/x-tex"},"2^n")])])]),(0,t._)("span",{class:"katex-html","aria-hidden":"true"},[(0,t._)("span",{class:"base"},[(0,t._)("span",{class:"strut",style:{height:"0.6644em"}}),(0,t._)("span",{class:"mord"},[(0,t._)("span",{class:"mord"},"2"),(0,t._)("span",{class:"msupsub"},[(0,t._)("span",{class:"vlist-t"},[(0,t._)("span",{class:"vlist-r"},[(0,t._)("span",{class:"vlist",style:{height:"0.6644em"}},[(0,t._)("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[(0,t._)("span",{class:"pstrut",style:{height:"2.7em"}}),(0,t._)("span",{class:"sizing reset-size6 size3 mtight"},[(0,t._)("span",{class:"mord mathnormal mtight"},"n")])])])])])])])])])]),(0,t.Uk)(" 替换下 b 就是：")],-1),l=(0,t._)("blockquote",null,[(0,t._)("p",null,[(0,t.Uk)("a % "),(0,t._)("span",{class:"katex"},[(0,t._)("span",{class:"katex-mathml"},[(0,t._)("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[(0,t._)("semantics",null,[(0,t._)("mrow",null,[(0,t._)("msup",null,[(0,t._)("mn",null,"2"),(0,t._)("mi",null,"n")])]),(0,t._)("annotation",{encoding:"application/x-tex"},"2^n")])])]),(0,t._)("span",{class:"katex-html","aria-hidden":"true"},[(0,t._)("span",{class:"base"},[(0,t._)("span",{class:"strut",style:{height:"0.6644em"}}),(0,t._)("span",{class:"mord"},[(0,t._)("span",{class:"mord"},"2"),(0,t._)("span",{class:"msupsub"},[(0,t._)("span",{class:"vlist-t"},[(0,t._)("span",{class:"vlist-r"},[(0,t._)("span",{class:"vlist",style:{height:"0.6644em"}},[(0,t._)("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[(0,t._)("span",{class:"pstrut",style:{height:"2.7em"}}),(0,t._)("span",{class:"sizing reset-size6 size3 mtight"},[(0,t._)("span",{class:"mord mathnormal mtight"},"n")])])])])])])])])])]),(0,t.Uk)(" = a & ("),(0,t._)("span",{class:"katex"},[(0,t._)("span",{class:"katex-mathml"},[(0,t._)("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[(0,t._)("semantics",null,[(0,t._)("mrow",null,[(0,t._)("msup",null,[(0,t._)("mn",null,"2"),(0,t._)("mi",null,"n")])]),(0,t._)("annotation",{encoding:"application/x-tex"},"2^n")])])]),(0,t._)("span",{class:"katex-html","aria-hidden":"true"},[(0,t._)("span",{class:"base"},[(0,t._)("span",{class:"strut",style:{height:"0.6644em"}}),(0,t._)("span",{class:"mord"},[(0,t._)("span",{class:"mord"},"2"),(0,t._)("span",{class:"msupsub"},[(0,t._)("span",{class:"vlist-t"},[(0,t._)("span",{class:"vlist-r"},[(0,t._)("span",{class:"vlist",style:{height:"0.6644em"}},[(0,t._)("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[(0,t._)("span",{class:"pstrut",style:{height:"2.7em"}}),(0,t._)("span",{class:"sizing reset-size6 size3 mtight"},[(0,t._)("span",{class:"mord mathnormal mtight"},"n")])])])])])])])])])]),(0,t.Uk)("-1)")])],-1),o=(0,t._)("p",null,[(0,t.Uk)("我们来验证一下，假如 a = 14，b = 8，也就是 "),(0,t._)("span",{class:"katex"},[(0,t._)("span",{class:"katex-mathml"},[(0,t._)("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[(0,t._)("semantics",null,[(0,t._)("mrow",null,[(0,t._)("msup",null,[(0,t._)("mn",null,"2"),(0,t._)("mn",null,"3")])]),(0,t._)("annotation",{encoding:"application/x-tex"},"2^3")])])]),(0,t._)("span",{class:"katex-html","aria-hidden":"true"},[(0,t._)("span",{class:"base"},[(0,t._)("span",{class:"strut",style:{height:"0.8141em"}}),(0,t._)("span",{class:"mord"},[(0,t._)("span",{class:"mord"},"2"),(0,t._)("span",{class:"msupsub"},[(0,t._)("span",{class:"vlist-t"},[(0,t._)("span",{class:"vlist-r"},[(0,t._)("span",{class:"vlist",style:{height:"0.8141em"}},[(0,t._)("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[(0,t._)("span",{class:"pstrut",style:{height:"2.7em"}}),(0,t._)("span",{class:"sizing reset-size6 size3 mtight"},[(0,t._)("span",{class:"mord mtight"},"3")])])])])])])])])])]),(0,t.Uk)("，n=3。")],-1),c=(0,t._)("p",null,[(0,t.Uk)("14%8，14 的二进制为 1110，8 的二进制 1000，8-1 = 7 的二进制为 0111，1110&0111=0110，也就是 0"),(0,t._)("code",null,"*"),(0,t._)("span",{class:"katex"},[(0,t._)("span",{class:"katex-mathml"},[(0,t._)("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[(0,t._)("semantics",null,[(0,t._)("mrow",null,[(0,t._)("msup",null,[(0,t._)("mn",null,"2"),(0,t._)("mn",null,"0")])]),(0,t._)("annotation",{encoding:"application/x-tex"},"2^0")])])]),(0,t._)("span",{class:"katex-html","aria-hidden":"true"},[(0,t._)("span",{class:"base"},[(0,t._)("span",{class:"strut",style:{height:"0.8141em"}}),(0,t._)("span",{class:"mord"},[(0,t._)("span",{class:"mord"},"2"),(0,t._)("span",{class:"msupsub"},[(0,t._)("span",{class:"vlist-t"},[(0,t._)("span",{class:"vlist-r"},[(0,t._)("span",{class:"vlist",style:{height:"0.8141em"}},[(0,t._)("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[(0,t._)("span",{class:"pstrut",style:{height:"2.7em"}}),(0,t._)("span",{class:"sizing reset-size6 size3 mtight"},[(0,t._)("span",{class:"mord mtight"},"0")])])])])])])])])])]),(0,t.Uk)("+1"),(0,t._)("code",null,"*"),(0,t._)("span",{class:"katex"},[(0,t._)("span",{class:"katex-mathml"},[(0,t._)("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[(0,t._)("semantics",null,[(0,t._)("mrow",null,[(0,t._)("msup",null,[(0,t._)("mn",null,"2"),(0,t._)("mn",null,"1")])]),(0,t._)("annotation",{encoding:"application/x-tex"},"2^1")])])]),(0,t._)("span",{class:"katex-html","aria-hidden":"true"},[(0,t._)("span",{class:"base"},[(0,t._)("span",{class:"strut",style:{height:"0.8141em"}}),(0,t._)("span",{class:"mord"},[(0,t._)("span",{class:"mord"},"2"),(0,t._)("span",{class:"msupsub"},[(0,t._)("span",{class:"vlist-t"},[(0,t._)("span",{class:"vlist-r"},[(0,t._)("span",{class:"vlist",style:{height:"0.8141em"}},[(0,t._)("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[(0,t._)("span",{class:"pstrut",style:{height:"2.7em"}}),(0,t._)("span",{class:"sizing reset-size6 size3 mtight"},[(0,t._)("span",{class:"mord mtight"},"1")])])])])])])])])])]),(0,t.Uk)("+1"),(0,t._)("code",null,"*"),(0,t._)("span",{class:"katex"},[(0,t._)("span",{class:"katex-mathml"},[(0,t._)("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[(0,t._)("semantics",null,[(0,t._)("mrow",null,[(0,t._)("msup",null,[(0,t._)("mn",null,"2"),(0,t._)("mn",null,"2")])]),(0,t._)("annotation",{encoding:"application/x-tex"},"2^2")])])]),(0,t._)("span",{class:"katex-html","aria-hidden":"true"},[(0,t._)("span",{class:"base"},[(0,t._)("span",{class:"strut",style:{height:"0.8141em"}}),(0,t._)("span",{class:"mord"},[(0,t._)("span",{class:"mord"},"2"),(0,t._)("span",{class:"msupsub"},[(0,t._)("span",{class:"vlist-t"},[(0,t._)("span",{class:"vlist-r"},[(0,t._)("span",{class:"vlist",style:{height:"0.8141em"}},[(0,t._)("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[(0,t._)("span",{class:"pstrut",style:{height:"2.7em"}}),(0,t._)("span",{class:"sizing reset-size6 size3 mtight"},[(0,t._)("span",{class:"mord mtight"},"2")])])])])])])])])])]),(0,t.Uk)("+0"),(0,t._)("code",null,"*"),(0,t._)("span",{class:"katex"},[(0,t._)("span",{class:"katex-mathml"},[(0,t._)("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[(0,t._)("semantics",null,[(0,t._)("mrow",null,[(0,t._)("msup",null,[(0,t._)("mn",null,"2"),(0,t._)("mn",null,"3")])]),(0,t._)("annotation",{encoding:"application/x-tex"},"2^3")])])]),(0,t._)("span",{class:"katex-html","aria-hidden":"true"},[(0,t._)("span",{class:"base"},[(0,t._)("span",{class:"strut",style:{height:"0.8141em"}}),(0,t._)("span",{class:"mord"},[(0,t._)("span",{class:"mord"},"2"),(0,t._)("span",{class:"msupsub"},[(0,t._)("span",{class:"vlist-t"},[(0,t._)("span",{class:"vlist-r"},[(0,t._)("span",{class:"vlist",style:{height:"0.8141em"}},[(0,t._)("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[(0,t._)("span",{class:"pstrut",style:{height:"2.7em"}}),(0,t._)("span",{class:"sizing reset-size6 size3 mtight"},[(0,t._)("span",{class:"mord mtight"},"3")])])])])])])])])])]),(0,t.Uk)("=0+2+4+0=6，14%8 刚好也等于 6。")],-1),i=(0,t.uE)('<p>这也正好解释了为什么 HashMap 的数组长度要取 2 的整次方。</p><p>因为（数组长度-1）正好相当于一个“低位掩码”——这个掩码的低位最好全是 1，这样 &amp; 操作才有意义，否则结果就肯定是 0，那么 &amp; 操作就没有意义了。</p><blockquote><p>a&amp;b 操作的结果是：a、b 中对应位同时为 1，则对应结果位为 1，否则为 0</p></blockquote><p>2 的整次幂刚好是偶数，偶数-1 是奇数，奇数的二进制最后一位是 1，保证了 hash &amp;(length-1) 的最后一位可能为 0，也可能为 1（这取决于 h 的值），即 &amp; 运算后的结果可能为偶数，也可能为奇数，这样便可以保证哈希值的均匀性。</p><p>&amp; 操作的结果就是将哈希值的高位全部归零，只保留低位值，用来做数组下标访问。</p><p>假设某哈希值为 <code>10100101 11000100 00100101</code>，用它来做取模运算，我们来看一下结果。HashMap 的初始长度为 16（内部是数组），16-1=15，二进制是 <code>00000000 00000000 00001111</code>（高位用 0 来补齐）：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>\t 10100101 11000100 00100101\n&amp;\t00000000 00000000 00001111\n----------------------------------\n\t 00000000 00000000 00000101\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因为 15 的高位全部是 0，所以 &amp; 运算后的高位结果肯定是 0，只剩下 4 个低位 <code>0101</code>，也就是十进制的 5，也就是将哈希值为 <code>10100101 11000100 00100101</code> 的键放在数组的第 5 位。</p><p>明白了取模运算后，我们再来看 put 方法的源码：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以及 get 方法的源码：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token class-name">HashMap<span class="token punctuation">.</span>Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span>\n    <span class="token keyword">return</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>它们在调用 putVal 和 getNode 之前，都会先调用 hash 方法：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">int</span> h<span class="token punctuation">;</span>\n    <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那为什么取模运算之前要调用 hash 方法呢？</p><p>看下面这个图。</p><p><img src="https://cdn.jsdelivr.net/gh/thinkingme/thinkingme.github.io@master/images/collection/hash-01.png" alt="" loading="lazy"></p><p>某哈希值为 <code>11111111 11111111 11110000 1110 1010</code>，将它右移 16 位（h &gt;&gt;&gt; 16），刚好是 <code>00000000 00000000 11111111 11111111</code>，再进行异或操作（h ^ (h &gt;&gt;&gt; 16)），结果是 <code>11111111 11111111 00001111 00010101</code></p><blockquote><p>异或（<code>^</code>）运算是基于二进制的位运算，采用符号 XOR 或者<code>^</code>来表示，运算规则是：如果是同值取 0、异值取 1</p></blockquote><p>由于混合了原来哈希值的高位和低位，所以低位的随机性加大了（掺杂了部分高位的特征，高位的信息也得到了保留）。</p><p>结果再与数组长度-1（<code>00000000 00000000 00000000 00001111</code>）做取模运算，得到的下标就是 <code>00000000 00000000 00000000 00000101</code>，也就是 5。</p><p>还记得之前我们假设的某哈希值 <code>10100101 11000100 00100101</code> 吗？在没有调用 hash 方法之前，与 15 做取模运算后的结果也是 5，我们不妨来看看调用 hash 之后的取模运算结果是多少。</p><p>某哈希值 <code>00000000 10100101 11000100 00100101</code>（补齐 32 位），将它右移 16 位（h &gt;&gt;&gt; 16），刚好是 <code>00000000 00000000 00000000 10100101</code>，再进行异或操作（h ^ (h &gt;&gt;&gt; 16)），结果是 <code>00000000 10100101 00111011 10000000</code></p><p>结果再与数组长度-1（<code>00000000 00000000 00000000 00001111</code>）做取模运算，得到的下标就是 <code>00000000 00000000 00000000 00000000</code>，也就是 0。</p><p>综上所述，hash 方法是用来做哈希值优化的，把哈希值右移 16 位，也就正好是自己长度的一半，之后与原哈希值做异或运算，这样就混合了原哈希值中的高位和低位，增大了随机性。</p><p>说白了，<strong>hash 方法就是为了增加随机性，让数据元素更加均衡的分布，减少碰撞</strong>。</p><h2 id="二、扩容机制" tabindex="-1"><a class="header-anchor" href="#二、扩容机制" aria-hidden="true">#</a> 二、扩容机制</h2>',27),u=(0,t.Uk)("大家都知道，数组一旦初始化后大小就无法改变了，所以就有了 "),r={href:"https://mp.weixin.qq.com/s/7puyi1PSbkFEIAz5zbNKxA",target:"_blank",rel:"noopener noreferrer"},k=(0,t.Uk)("ArrayList"),d=(0,t.Uk)("这种“动态数组”，可以自动扩容。"),m=(0,t.uE)('<p>HashMap 的底层用的也是数组。向 HashMap 里不停地添加元素，当数组无法装载更多元素时，就需要对数组进行扩容，以便装入更多的元素。</p><p>当然了，数组是无法自动扩容的，所以如果要扩容的话，就需要新建一个大的数组，然后把小数组的元素复制过去。</p><p>HashMap 的扩容是通过 resize 方法来实现的，JDK 8 中融入了红黑树，比较复杂，为了便于理解，就还使用 JDK 7 的源码，搞清楚了 JDK 7 的，我们后面再详细说明 JDK 8 和 JDK 7 之间的区别。</p><p>resize 方法的源码：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// newCapacity为新的容量</span>\n<span class="token keyword">void</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token keyword">int</span> newCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 小数组，临时过度下</span>\n    <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> oldTable <span class="token operator">=</span> table<span class="token punctuation">;</span>\n    <span class="token comment">// 扩容前的容量</span>\n    <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> oldTable<span class="token punctuation">.</span>length<span class="token punctuation">;</span>\n    <span class="token comment">// MAXIMUM_CAPACITY 为最大容量，2 的 30 次方 = 1&lt;&lt;30</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">==</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 容量调整为 Integer 的最大值 0x7fffffff（十六进制）=2 的 31 次方-1</span>\n        threshold <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>\n        <span class="token keyword">return</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token comment">// 初始化一个新的数组（大容量）</span>\n    <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span>newCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span>\n    <span class="token comment">// 把小数组的元素转移到大数组中</span>\n    <span class="token function">transfer</span><span class="token punctuation">(</span>newTable<span class="token punctuation">,</span> <span class="token function">initHashSeedAsNeeded</span><span class="token punctuation">(</span>newCapacity<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token comment">// 引用新的大数组</span>\n    table <span class="token operator">=</span> newTable<span class="token punctuation">;</span>\n    <span class="token comment">// 重新计算阈值</span>\n    threshold <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>newCapacity <span class="token operator">*</span> loadFactor<span class="token punctuation">,</span> MAXIMUM_CAPACITY <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>代码注释里出现了左移（<code>&lt;&lt;</code>），这里简单介绍一下：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>a=39\nb = a &lt;&lt; 2\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>十进制 39 用 8 位的二进制来表示，就是 00100111，左移两位后是 10011100（低位用 0 补上），再转成十进制数就是 156。</p><p>移位运算通常可以用来代替乘法运算和除法运算。例如，将 0010011（39）左移两位就是 10011100（156），刚好变成了原来的 4 倍。</p><p>实际上呢，二进制数左移后会变成原来的 2 倍、4 倍、8 倍。</p><p>transfer 方法用来转移，将小数组的元素拷贝到新的数组中。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTable<span class="token punctuation">,</span> <span class="token keyword">boolean</span> rehash<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 新的容量</span>\n    <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> newTable<span class="token punctuation">.</span>length<span class="token punctuation">;</span>\n    <span class="token comment">// 遍历小数组</span>\n    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e <span class="token operator">:</span> table<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">!=</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token comment">// 拉链法，相同 key 上的不同值</span>\n            <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>\n            <span class="token comment">// 是否需要重新计算 hash</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>rehash<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                e<span class="token punctuation">.</span>hash <span class="token operator">=</span> <span class="token keyword">null</span> <span class="token operator">==</span> e<span class="token punctuation">.</span>key <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token function">hash</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n            <span class="token comment">// 根据大数组的容量，和键的 hash 计算元素在数组中的下标</span>\n            <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n            <span class="token comment">// 同一位置上的新元素被放在链表的头部</span>\n            e<span class="token punctuation">.</span>next <span class="token operator">=</span> newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>\n\n            <span class="token comment">// 放在新的数组上</span>\n            newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>\n\n            <span class="token comment">// 链表上的下一个元素</span>\n            e <span class="token operator">=</span> next<span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>e.next = newTable[i]</code>，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到链表的尾部（如果发生了 hash 冲突的话），这一点和 JDK 8 有区别。</p><p><strong>在旧数组中同一个链表上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上</strong>（仔细看下面的内容，会解释清楚这一点）。</p>',14),h=(0,t.Uk)("假设 hash 算法（"),v={href:"https://mp.weixin.qq.com/s/aS2dg4Dj1Efwujmv-6YTBg",target:"_blank",rel:"noopener noreferrer"},g=(0,t.Uk)("之前的章节有讲到"),b=(0,t.Uk)("，点击链接再温故一下）就是简单的用键的哈希值（一个 int 值）和数组大小取模（也就是 hashCode % table.length）。"),_=(0,t.uE)('<p>继续假设：</p><ul><li>数组 table 的长度为 2</li><li>键的哈希值为 3、7、5</li></ul><p>取模运算后，哈希冲突都到 table[1] 上了，因为余数为 1。那么扩容前的样子如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/thinkingme/thinkingme.github.io@master/images/collection/hashmap-resize-01.png" alt="" loading="lazy"></p><p>小数组的容量为 2， key 3、7、5 都在 table[1] 的链表上。</p><p>假设负载因子 loadFactor 为 1，也就是当元素的实际大小大于 table 的实际大小时进行扩容。</p><p>扩容后的大数组的容量为 4。</p><ul><li>key 3 取模（3%4）后是 3，放在 table[3] 上。</li><li>key 7 取模（7%4）后是 3，放在 table[3] 上的链表头部。</li><li>key 5 取模（5%4）后是 1，放在 table[1] 上。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/thinkingme/thinkingme.github.io@master/images/collection/hashmap-resize-02.png" alt="" loading="lazy"></p><p>按照我们的预期，扩容后的 7 仍然应该在 3 这条链表的后面，但实际上呢？ 7 跑到 3 这条链表的头部了。针对 JDK 7 中的这个情况，JDK 8 做了哪些优化呢？</p><p>看下面这张图。</p><p><img src="https://cdn.jsdelivr.net/gh/thinkingme/thinkingme.github.io@master/images/collection/hashmap-resize-03.png" alt="" loading="lazy"></p><p>n 为 table 的长度，默认值为 16。</p>',13),y=(0,t._)("ul",null,[(0,t._)("li",null,[(0,t.Uk)("n-1 也就是二进制的 0000 1111（1X"),(0,t._)("span",{class:"katex"},[(0,t._)("span",{class:"katex-mathml"},[(0,t._)("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[(0,t._)("semantics",null,[(0,t._)("mrow",null,[(0,t._)("msup",null,[(0,t._)("mn",null,"2"),(0,t._)("mn",null,"0")])]),(0,t._)("annotation",{encoding:"application/x-tex"},"2^0")])])]),(0,t._)("span",{class:"katex-html","aria-hidden":"true"},[(0,t._)("span",{class:"base"},[(0,t._)("span",{class:"strut",style:{height:"0.8141em"}}),(0,t._)("span",{class:"mord"},[(0,t._)("span",{class:"mord"},"2"),(0,t._)("span",{class:"msupsub"},[(0,t._)("span",{class:"vlist-t"},[(0,t._)("span",{class:"vlist-r"},[(0,t._)("span",{class:"vlist",style:{height:"0.8141em"}},[(0,t._)("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[(0,t._)("span",{class:"pstrut",style:{height:"2.7em"}}),(0,t._)("span",{class:"sizing reset-size6 size3 mtight"},[(0,t._)("span",{class:"mord mtight"},"0")])])])])])])])])])]),(0,t.Uk)("+1X"),(0,t._)("span",{class:"katex"},[(0,t._)("span",{class:"katex-mathml"},[(0,t._)("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[(0,t._)("semantics",null,[(0,t._)("mrow",null,[(0,t._)("msup",null,[(0,t._)("mn",null,"2"),(0,t._)("mn",null,"1")])]),(0,t._)("annotation",{encoding:"application/x-tex"},"2^1")])])]),(0,t._)("span",{class:"katex-html","aria-hidden":"true"},[(0,t._)("span",{class:"base"},[(0,t._)("span",{class:"strut",style:{height:"0.8141em"}}),(0,t._)("span",{class:"mord"},[(0,t._)("span",{class:"mord"},"2"),(0,t._)("span",{class:"msupsub"},[(0,t._)("span",{class:"vlist-t"},[(0,t._)("span",{class:"vlist-r"},[(0,t._)("span",{class:"vlist",style:{height:"0.8141em"}},[(0,t._)("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[(0,t._)("span",{class:"pstrut",style:{height:"2.7em"}}),(0,t._)("span",{class:"sizing reset-size6 size3 mtight"},[(0,t._)("span",{class:"mord mtight"},"1")])])])])])])])])])]),(0,t.Uk)("+1X"),(0,t._)("span",{class:"katex"},[(0,t._)("span",{class:"katex-mathml"},[(0,t._)("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[(0,t._)("semantics",null,[(0,t._)("mrow",null,[(0,t._)("msup",null,[(0,t._)("mn",null,"2"),(0,t._)("mn",null,"2")])]),(0,t._)("annotation",{encoding:"application/x-tex"},"2^2")])])]),(0,t._)("span",{class:"katex-html","aria-hidden":"true"},[(0,t._)("span",{class:"base"},[(0,t._)("span",{class:"strut",style:{height:"0.8141em"}}),(0,t._)("span",{class:"mord"},[(0,t._)("span",{class:"mord"},"2"),(0,t._)("span",{class:"msupsub"},[(0,t._)("span",{class:"vlist-t"},[(0,t._)("span",{class:"vlist-r"},[(0,t._)("span",{class:"vlist",style:{height:"0.8141em"}},[(0,t._)("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[(0,t._)("span",{class:"pstrut",style:{height:"2.7em"}}),(0,t._)("span",{class:"sizing reset-size6 size3 mtight"},[(0,t._)("span",{class:"mord mtight"},"2")])])])])])])])])])]),(0,t.Uk)("+1X"),(0,t._)("span",{class:"katex"},[(0,t._)("span",{class:"katex-mathml"},[(0,t._)("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[(0,t._)("semantics",null,[(0,t._)("mrow",null,[(0,t._)("msup",null,[(0,t._)("mn",null,"2"),(0,t._)("mn",null,"3")])]),(0,t._)("annotation",{encoding:"application/x-tex"},"2^3")])])]),(0,t._)("span",{class:"katex-html","aria-hidden":"true"},[(0,t._)("span",{class:"base"},[(0,t._)("span",{class:"strut",style:{height:"0.8141em"}}),(0,t._)("span",{class:"mord"},[(0,t._)("span",{class:"mord"},"2"),(0,t._)("span",{class:"msupsub"},[(0,t._)("span",{class:"vlist-t"},[(0,t._)("span",{class:"vlist-r"},[(0,t._)("span",{class:"vlist",style:{height:"0.8141em"}},[(0,t._)("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[(0,t._)("span",{class:"pstrut",style:{height:"2.7em"}}),(0,t._)("span",{class:"sizing reset-size6 size3 mtight"},[(0,t._)("span",{class:"mord mtight"},"3")])])])])])])])])])]),(0,t.Uk)("=1+2+4+8=15）；")]),(0,t._)("li",null,"key1 哈希值的最后 8 位为 0000 0101"),(0,t._)("li",null,"key2 哈希值的最后 8 位为 0001 0101（和 key1 不同）"),(0,t._)("li",null,"做与运算后发生了哈希冲突，索引都在（0000 0101）上。")],-1),w=(0,t._)("p",null,"扩容后为 32。",-1),f=(0,t._)("ul",null,[(0,t._)("li",null,[(0,t.Uk)("n-1 也就是二进制的 0001 1111（1X"),(0,t._)("span",{class:"katex"},[(0,t._)("span",{class:"katex-mathml"},[(0,t._)("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[(0,t._)("semantics",null,[(0,t._)("mrow",null,[(0,t._)("msup",null,[(0,t._)("mn",null,"2"),(0,t._)("mn",null,"0")])]),(0,t._)("annotation",{encoding:"application/x-tex"},"2^0")])])]),(0,t._)("span",{class:"katex-html","aria-hidden":"true"},[(0,t._)("span",{class:"base"},[(0,t._)("span",{class:"strut",style:{height:"0.8141em"}}),(0,t._)("span",{class:"mord"},[(0,t._)("span",{class:"mord"},"2"),(0,t._)("span",{class:"msupsub"},[(0,t._)("span",{class:"vlist-t"},[(0,t._)("span",{class:"vlist-r"},[(0,t._)("span",{class:"vlist",style:{height:"0.8141em"}},[(0,t._)("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[(0,t._)("span",{class:"pstrut",style:{height:"2.7em"}}),(0,t._)("span",{class:"sizing reset-size6 size3 mtight"},[(0,t._)("span",{class:"mord mtight"},"0")])])])])])])])])])]),(0,t.Uk)("+1X"),(0,t._)("span",{class:"katex"},[(0,t._)("span",{class:"katex-mathml"},[(0,t._)("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[(0,t._)("semantics",null,[(0,t._)("mrow",null,[(0,t._)("msup",null,[(0,t._)("mn",null,"2"),(0,t._)("mn",null,"1")])]),(0,t._)("annotation",{encoding:"application/x-tex"},"2^1")])])]),(0,t._)("span",{class:"katex-html","aria-hidden":"true"},[(0,t._)("span",{class:"base"},[(0,t._)("span",{class:"strut",style:{height:"0.8141em"}}),(0,t._)("span",{class:"mord"},[(0,t._)("span",{class:"mord"},"2"),(0,t._)("span",{class:"msupsub"},[(0,t._)("span",{class:"vlist-t"},[(0,t._)("span",{class:"vlist-r"},[(0,t._)("span",{class:"vlist",style:{height:"0.8141em"}},[(0,t._)("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[(0,t._)("span",{class:"pstrut",style:{height:"2.7em"}}),(0,t._)("span",{class:"sizing reset-size6 size3 mtight"},[(0,t._)("span",{class:"mord mtight"},"1")])])])])])])])])])]),(0,t.Uk)("+1X"),(0,t._)("span",{class:"katex"},[(0,t._)("span",{class:"katex-mathml"},[(0,t._)("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[(0,t._)("semantics",null,[(0,t._)("mrow",null,[(0,t._)("msup",null,[(0,t._)("mn",null,"2"),(0,t._)("mn",null,"2")])]),(0,t._)("annotation",{encoding:"application/x-tex"},"2^2")])])]),(0,t._)("span",{class:"katex-html","aria-hidden":"true"},[(0,t._)("span",{class:"base"},[(0,t._)("span",{class:"strut",style:{height:"0.8141em"}}),(0,t._)("span",{class:"mord"},[(0,t._)("span",{class:"mord"},"2"),(0,t._)("span",{class:"msupsub"},[(0,t._)("span",{class:"vlist-t"},[(0,t._)("span",{class:"vlist-r"},[(0,t._)("span",{class:"vlist",style:{height:"0.8141em"}},[(0,t._)("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[(0,t._)("span",{class:"pstrut",style:{height:"2.7em"}}),(0,t._)("span",{class:"sizing reset-size6 size3 mtight"},[(0,t._)("span",{class:"mord mtight"},"2")])])])])])])])])])]),(0,t.Uk)("+1X"),(0,t._)("span",{class:"katex"},[(0,t._)("span",{class:"katex-mathml"},[(0,t._)("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[(0,t._)("semantics",null,[(0,t._)("mrow",null,[(0,t._)("msup",null,[(0,t._)("mn",null,"2"),(0,t._)("mn",null,"3")])]),(0,t._)("annotation",{encoding:"application/x-tex"},"2^3")])])]),(0,t._)("span",{class:"katex-html","aria-hidden":"true"},[(0,t._)("span",{class:"base"},[(0,t._)("span",{class:"strut",style:{height:"0.8141em"}}),(0,t._)("span",{class:"mord"},[(0,t._)("span",{class:"mord"},"2"),(0,t._)("span",{class:"msupsub"},[(0,t._)("span",{class:"vlist-t"},[(0,t._)("span",{class:"vlist-r"},[(0,t._)("span",{class:"vlist",style:{height:"0.8141em"}},[(0,t._)("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[(0,t._)("span",{class:"pstrut",style:{height:"2.7em"}}),(0,t._)("span",{class:"sizing reset-size6 size3 mtight"},[(0,t._)("span",{class:"mord mtight"},"3")])])])])])])])])])]),(0,t.Uk)("+1X"),(0,t._)("span",{class:"katex"},[(0,t._)("span",{class:"katex-mathml"},[(0,t._)("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[(0,t._)("semantics",null,[(0,t._)("mrow",null,[(0,t._)("msup",null,[(0,t._)("mn",null,"2"),(0,t._)("mn",null,"4")])]),(0,t._)("annotation",{encoding:"application/x-tex"},"2^4")])])]),(0,t._)("span",{class:"katex-html","aria-hidden":"true"},[(0,t._)("span",{class:"base"},[(0,t._)("span",{class:"strut",style:{height:"0.8141em"}}),(0,t._)("span",{class:"mord"},[(0,t._)("span",{class:"mord"},"2"),(0,t._)("span",{class:"msupsub"},[(0,t._)("span",{class:"vlist-t"},[(0,t._)("span",{class:"vlist-r"},[(0,t._)("span",{class:"vlist",style:{height:"0.8141em"}},[(0,t._)("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[(0,t._)("span",{class:"pstrut",style:{height:"2.7em"}}),(0,t._)("span",{class:"sizing reset-size6 size3 mtight"},[(0,t._)("span",{class:"mord mtight"},"4")])])])])])])])])])]),(0,t.Uk)("=1+2+4+8+16=31），扩容前是 0000 1111。")]),(0,t._)("li",null,"key1 哈希值的低位为 0000 0101"),(0,t._)("li",null,"key2 哈希值的低位为 0001 0101（和 key1 不同）"),(0,t._)("li",null,"key1 做与运算后，索引为 0000 0101。"),(0,t._)("li",null,"key2 做与运算后，索引为 0001 0101。")],-1),x=(0,t.uE)('<p>新的索引就会发生这样的变化：</p><ul><li>原来的索引是 5（<em>0</em> 0101）</li><li>原来的容量是 16</li><li>扩容后的容量是 32</li><li>扩容后的索引是 21（<em>1</em> 0101），也就是 5+16，也就是原来的索引+原来的容量</li></ul><p><img src="https://cdn.jsdelivr.net/gh/thinkingme/thinkingme.github.io@master/images/collection/hashmap-resize-04.png" alt="" loading="lazy"></p><p>也就是说，JDK 8 不需要像 JDK 7 那样重新计算 hash，只需要看原来的 hash 值新增的那个 bit 是 1 还是 0 就好了，是 0 的话就表示索引没变，是 1 的话，索引就变成了“原索引+原来的容量”。</p><p><img src="https://cdn.jsdelivr.net/gh/thinkingme/thinkingme.github.io@master/images/collection/hashmap-resize-05.png" alt="" loading="lazy"></p><p>JDK 8 的这个设计非常巧妙，既省去了重新计算 hash 的时间，同时，由于新增的 1 bit 是 0 还是 1 是随机的，因此扩容的过程，可以均匀地把之前的节点分散到新的位置上。</p><p>woc，只能说 HashMap 的作者 Doug Lea、Josh Bloch、Arthur van Hoff、Neal Gafter 真的强——的一笔。</p><p>JDK 8 扩容的源代码：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> oldTab <span class="token operator">=</span> table<span class="token punctuation">;</span>\n    <span class="token keyword">int</span> oldCap <span class="token operator">=</span> <span class="token punctuation">(</span>oldTab <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> oldTab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>\n    <span class="token keyword">int</span> oldThr <span class="token operator">=</span> threshold<span class="token punctuation">;</span>\n    <span class="token keyword">int</span> newCap<span class="token punctuation">,</span> newThr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">&gt;=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            threshold <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>\n            <span class="token keyword">return</span> oldTab<span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        <span class="token comment">// 没超过最大值，就扩充为原来的2倍</span>\n        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newCap <span class="token operator">=</span> oldCap <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span>\n                 oldCap <span class="token operator">&gt;=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span>\n            newThr <span class="token operator">=</span> oldThr <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// double threshold</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldThr <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// initial capacity was placed in threshold</span>\n        newCap <span class="token operator">=</span> oldThr<span class="token punctuation">;</span>\n    <span class="token keyword">else</span> <span class="token punctuation">{</span>               <span class="token comment">// zero initial threshold signifies using defaults</span>\n        newCap <span class="token operator">=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">;</span>\n        newThr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>DEFAULT_LOAD_FACTOR <span class="token operator">*</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token comment">// 计算新的resize上限</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>newThr <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">float</span> ft <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>newCap <span class="token operator">*</span> loadFactor<span class="token punctuation">;</span>\n        newThr <span class="token operator">=</span> <span class="token punctuation">(</span>newCap <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span> ft <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>MAXIMUM_CAPACITY <span class="token operator">?</span>\n                  <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>ft <span class="token operator">:</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    threshold <span class="token operator">=</span> newThr<span class="token punctuation">;</span>\n    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">&quot;rawtypes&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;unchecked&quot;</span><span class="token punctuation">}</span><span class="token punctuation">)</span>\n        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTab <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>newCap<span class="token punctuation">]</span><span class="token punctuation">;</span>\n    table <span class="token operator">=</span> newTab<span class="token punctuation">;</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldTab <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 小数组复制到大数组</span>\n        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> oldCap<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>\n                    newTab<span class="token punctuation">[</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>newCap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>\n                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>\n                    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> newTab<span class="token punctuation">,</span> j<span class="token punctuation">,</span> oldCap<span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// preserve order</span>\n                    <span class="token comment">// 链表优化重 hash 的代码块</span>\n                    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> loHead <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> loTail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n                    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> hiHead <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> hiTail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n                    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">;</span>\n                    <span class="token keyword">do</span> <span class="token punctuation">{</span>\n                        next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>\n                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> oldCap<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                            <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>\n                                loHead <span class="token operator">=</span> e<span class="token punctuation">;</span>\n                            <span class="token keyword">else</span>\n                                loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>\n                            loTail <span class="token operator">=</span> e<span class="token punctuation">;</span>\n                        <span class="token punctuation">}</span>\n                        <span class="token keyword">else</span> <span class="token punctuation">{</span>\n                            <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>\n                                hiHead <span class="token operator">=</span> e<span class="token punctuation">;</span>\n                            <span class="token keyword">else</span>\n                                hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>\n                            hiTail <span class="token operator">=</span> e<span class="token punctuation">;</span>\n                        <span class="token punctuation">}</span>\n                    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                    <span class="token comment">// 原来的索引</span>\n                    <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                        loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n                        newTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">;</span>\n                    <span class="token punctuation">}</span>\n                    <span class="token comment">// 索引+原来的容量</span>\n                    <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                        hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n                        newTab<span class="token punctuation">[</span>j <span class="token operator">+</span> oldCap<span class="token punctuation">]</span> <span class="token operator">=</span> hiHead<span class="token punctuation">;</span>\n                    <span class="token punctuation">}</span>\n                <span class="token punctuation">}</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">return</span> newTab<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="三、加载因子为什么是-0-75" tabindex="-1"><a class="header-anchor" href="#三、加载因子为什么是-0-75" aria-hidden="true">#</a> 三、加载因子为什么是 0.75</h2><p>JDK 8 中的 HashMap 是用数组+链表+红黑树实现的，我们要想往 HashMap 中放数据或者取数据，就需要确定数据在数组中的下标。</p><p>先把数据的键进行一次 hash：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">int</span> h<span class="token punctuation">;</span>\n    <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再做一次取模运算确定下标：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>i = (n - 1) &amp; hash\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>哈希表这样的数据结构容易产生两个问题：</p><ul><li>数组的容量过小，经过哈希计算后的下标，容易出现冲突；</li><li>数组的容量过大，导致空间利用率不高。</li></ul><p>加载因子是用来表示 HashMap 中数据的填满程度：</p><blockquote><p>加载因子 = 填入哈希表中的数据个数 / 哈希表的长度</p></blockquote><p>这就意味着：</p><ul><li>加载因子越小，填满的数据就越少，哈希冲突的几率就减少了，但浪费了空间，而且还会提高扩容的触发几率；</li><li>加载因子越大，填满的数据就越多，空间利用率就高，但哈希冲突的几率就变大了。</li></ul><p>好难！！！！</p><p>这就必须在“<strong>哈希冲突</strong>”与“<strong>空间利用率</strong>”两者之间有所取舍，尽量保持平衡，谁也不碍着谁。</p><p>我们知道，HashMap 是通过拉链法来解决哈希冲突的。</p>',24),M=(0,t.Uk)("为了减少哈希冲突发生的概率，当 HashMap 的数组长度达到一个"),T=(0,t._)("strong",null,"临界值",-1),z=(0,t.Uk)("的时候，就会触发扩容（可以点击"),A={href:"https://mp.weixin.qq.com/s/0KSpdBJMfXSVH63XadVdmw",target:"_blank",rel:"noopener noreferrer"},C=(0,t.Uk)("链接"),j=(0,t.Uk)("查看 HashMap 的扩容机制），扩容后会将之前小数组中的元素转移到大数组中，这是一个相当耗时的操作。"),U=(0,t.uE)('<p>这个临界值由什么来确定呢？</p><blockquote><p>临界值 = 初始容量 * 加载因子</p></blockquote><p>一开始，HashMap 的容量是 16：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_INITIAL_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment">// aka 16</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>加载因子是 0.75：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">float</span> DEFAULT_LOAD_FACTOR <span class="token operator">=</span> <span class="token number">0.75f</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>也就是说，当 16*0.75=12 时，会触发扩容机制。</p><p>为什么加载因子会选择 0.75 呢？为什么不是 0.8、0.6 呢？</p><p>这跟统计学里的一个很重要的原理——泊松分布有关。</p><p>是时候上维基百科了：</p><blockquote><p>泊松分布，是一种统计与概率学里常见到的离散概率分布，由法国数学家西莫恩·德尼·泊松在 1838 年时提出。它会对随机事件的发生次数进行建模，适用于涉及计算在给定的时间段、距离、面积等范围内发生随机事件的次数的应用情形。</p></blockquote><p>阮一峰老师曾在一篇博文中详细的介绍了泊松分布和指数分布，大家可以去看一下。</p>',12),I=(0,t.Uk)("链接："),N={href:"https://www.ruanyifeng.com/blog/2015/06/poisson-distribution.html",target:"_blank",rel:"noopener noreferrer"},V=(0,t.Uk)("https://www.ruanyifeng.com/blog/2015/06/poisson-distribution.html"),K=(0,t.uE)('<p>具体是用这么一个公式来表示的。</p><p><img src="https://cdn.jsdelivr.net/gh/thinkingme/thinkingme.github.io@master/images/collection/hashmap-loadfactor-01.png" alt="" loading="lazy"></p><p>等号的左边，P 表示概率，N 表示某种函数关系，t 表示时间，n 表示数量。</p><p>在 HashMap 的 doc 文档里，曾有这么一段描述：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Because TreeNodes are about twice the size of regular nodes, we\nuse them only when bins contain enough nodes to warrant use\n(see TREEIFY_THRESHOLD). And when they become too small (due to\nremoval or resizing) they are converted back to plain bins.  In\nusages with well-distributed user hashCodes, tree bins are\nrarely used.  Ideally, under random hashCodes, the frequency of\nnodes in bins follows a Poisson distribution\n(http://en.wikipedia.org/wiki/Poisson_distribution) with a\nparameter of about 0.5 on average for the default resizing\nthreshold of 0.75, although with a large variance because of\nresizing granularity. Ignoring variance, the expected\noccurrences of list size k are (exp(-0.5) * pow(0.5, k) /\nfactorial(k)). The first values are:\n0:    0.60653066\n1:    0.30326533\n2:    0.07581633\n3:    0.01263606\n4:    0.00157952\n5:    0.00015795\n6:    0.00001316\n7:    0.00000094\n8:    0.00000006\nmore: less than 1 in ten million\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>大致的意思就是：</p><p>因为 TreeNode（红黑树）的大小约为链表节点的两倍，所以我们只有在一个拉链已经拉了足够节点的时候才会转为 tree（参考 TREEIFY_THRESHOLD）。并且，当这个 hash 桶的节点因为移除或者扩容后 resize 数量变小的时候，我们会将树再转为拉链。如果一个用户的数据的 hashcode 值分布得很均匀的话，就会很少使用到红黑树。</p><p>理想情况下，我们使用随机的 hashcode 值，加载因子为 0.75 情况，尽管由于粒度调整会产生较大的方差，节点的分布频率仍然会服从参数为 0.5 的泊松分布。链表的长度为 8 发生的概率仅有 0.00000006。</p><p>虽然这段话的本意更多的是表示 jdk 8 中为什么拉链长度超过 8 的时候进行了红黑树转换，但提到了 0.75 这个加载因子——但这并不是为什么加载因子是 0.75 的答案。</p><p>为了搞清楚到底为什么，我看到了这篇文章：</p>',10),L=(0,t.Uk)("参考链接："),E={href:"https://segmentfault.com/a/1190000023308658",target:"_blank",rel:"noopener noreferrer"},H=(0,t.Uk)("https://segmentfault.com/a/1190000023308658"),q=(0,t.uE)('<p>里面提到了一个概念：<strong>二项分布</strong>（二哥概率论没学好，只能简单说一说）。</p><p>在做一件事情的时候，其结果的概率只有 2 种情况，和抛硬币一样，不是正面就是反面。</p><p>为此，我们做了 N 次实验，那么在每次试验中只有两种可能的结果，并且每次实验是独立的，不同实验之间互不影响，每次实验成功的概率都是一样的。</p><p>以此理论为基础，我们来做这样的实验：我们往哈希表中扔数据，如果发生哈希冲突就为失败，否则为成功。</p><p>我们可以设想，实验的 hash 值是随机的，并且经过 hash 运算的键都会映射到 hash 表的地址空间上，那么这个结果也是随机的。所以，每次 put 的时候就相当于我们在扔一个 16 面（我们先假设默认长度为 16）的骰子，扔骰子实验那肯定是相互独立的。碰撞发生即扔了 n 次有出现重复数字。</p><p>然后，我们的目的是啥呢？</p><p>就是掷了 k 次骰子，没有一次是相同的概率，需要尽可能的大些，一般意义上我们肯定要大于 0.5（这个数是个理想数，但是我是能接受的）。</p><p>于是，n 次事件里面，碰撞为 0 的概率，由上面公式得：</p><p><img src="https://cdn.jsdelivr.net/gh/thinkingme/thinkingme.github.io@master/images/collection/hashmap-loadfactor-02.png" alt="" loading="lazy"></p><p>这个概率值需要大于 0.5，我们认为这样的 hashmap 可以提供很低的碰撞率。所以：</p><p><img src="https://cdn.jsdelivr.net/gh/thinkingme/thinkingme.github.io@master/images/collection/hashmap-loadfactor-03png" alt="" loading="lazy"></p>',11),D=(0,t._)("p",null,[(0,t.Uk)("这时候，我们对于该公式其实最想求的时候长度 s 的时候，n 为多少次就应该进行扩容了？而负载因子则是"),(0,t._)("span",{class:"katex"},[(0,t._)("span",{class:"katex-mathml"},[(0,t._)("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[(0,t._)("semantics",null,[(0,t._)("mrow",null,[(0,t._)("mi",null,"n"),(0,t._)("mi",{mathvariant:"normal"},"/"),(0,t._)("mi",null,"s")]),(0,t._)("annotation",{encoding:"application/x-tex"},"n/s")])])]),(0,t._)("span",{class:"katex-html","aria-hidden":"true"},[(0,t._)("span",{class:"base"},[(0,t._)("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),(0,t._)("span",{class:"mord mathnormal"},"n"),(0,t._)("span",{class:"mord"},"/"),(0,t._)("span",{class:"mord mathnormal"},"s")])])]),(0,t.Uk)("的值。所以推导如下：")],-1),X=(0,t._)("p",null,[(0,t._)("img",{src:"https://cdn.jsdelivr.net/gh/thinkingme/thinkingme.github.io@master/images/collection/hashmap-loadfactor-04.png",alt:"",loading:"lazy"})],-1),P=(0,t._)("p",null,"所以可以得到",-1),J=(0,t._)("p",null,[(0,t._)("img",{src:"https://cdn.jsdelivr.net/gh/thinkingme/thinkingme.github.io@master/images/collection/hashmap-loadfactor-05.png",alt:"",loading:"lazy"})],-1),Y=(0,t._)("p",null,"其中",-1),F=(0,t._)("p",null,[(0,t._)("img",{src:"https://cdn.jsdelivr.net/gh/thinkingme/thinkingme.github.io@master/images/collection/hashmap-loadfactor-06.png",alt:"",loading:"lazy"})],-1),O=(0,t._)("p",null,[(0,t.Uk)("这就是一个求 "),(0,t._)("code",null,"∞⋅0"),(0,t.Uk)("函数极限问题，这里我们先令"),(0,t._)("span",{class:"katex"},[(0,t._)("span",{class:"katex-mathml"},[(0,t._)("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[(0,t._)("semantics",null,[(0,t._)("mrow",null,[(0,t._)("mi",null,"s"),(0,t._)("mo",null,"="),(0,t._)("mi",null,"m"),(0,t._)("mo",null,"+"),(0,t._)("mn",null,"1"),(0,t._)("mtext",null,"（"),(0,t._)("mi",null,"m"),(0,t._)("mo",null,"→"),(0,t._)("mi",{mathvariant:"normal"},"∞"),(0,t._)("mtext",null,"）")]),(0,t._)("annotation",{encoding:"application/x-tex"},"s = m+1（m \\to \\infty）")])])]),(0,t._)("span",{class:"katex-html","aria-hidden":"true"},[(0,t._)("span",{class:"base"},[(0,t._)("span",{class:"strut",style:{height:"0.4306em"}}),(0,t._)("span",{class:"mord mathnormal"},"s"),(0,t._)("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),(0,t._)("span",{class:"mrel"},"="),(0,t._)("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),(0,t._)("span",{class:"base"},[(0,t._)("span",{class:"strut",style:{height:"0.6667em","vertical-align":"-0.0833em"}}),(0,t._)("span",{class:"mord mathnormal"},"m"),(0,t._)("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),(0,t._)("span",{class:"mbin"},"+"),(0,t._)("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),(0,t._)("span",{class:"base"},[(0,t._)("span",{class:"strut",style:{height:"0.6833em"}}),(0,t._)("span",{class:"mord"},"1"),(0,t._)("span",{class:"mord cjk_fallback"},"（"),(0,t._)("span",{class:"mord mathnormal"},"m"),(0,t._)("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),(0,t._)("span",{class:"mrel"},"→"),(0,t._)("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),(0,t._)("span",{class:"base"},[(0,t._)("span",{class:"strut",style:{height:"0.6833em"}}),(0,t._)("span",{class:"mord"},"∞"),(0,t._)("span",{class:"mord cjk_fallback"},"）")])])]),(0,t.Uk)("则转化为")],-1),B=(0,t._)("p",null,[(0,t._)("img",{src:"https://cdn.jsdelivr.net/gh/thinkingme/thinkingme.github.io@master/images/collection/hashmap-loadfactor-07.png",alt:"",loading:"lazy"})],-1),S=(0,t._)("p",null,[(0,t.Uk)("我们再令 "),(0,t._)("span",{class:"katex"},[(0,t._)("span",{class:"katex-mathml"},[(0,t._)("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[(0,t._)("semantics",null,[(0,t._)("mrow",null,[(0,t._)("mi",null,"x"),(0,t._)("mo",null,"="),(0,t._)("mfrac",null,[(0,t._)("mn",null,"1"),(0,t._)("mi",null,"m")]),(0,t._)("mtext",null,"（"),(0,t._)("mi",null,"x"),(0,t._)("mo",null,"→"),(0,t._)("mn",null,"0"),(0,t._)("mtext",null,"）")]),(0,t._)("annotation",{encoding:"application/x-tex"},"x = \\frac{1}{m} （x \\to 0）")])])]),(0,t._)("span",{class:"katex-html","aria-hidden":"true"},[(0,t._)("span",{class:"base"},[(0,t._)("span",{class:"strut",style:{height:"0.4306em"}}),(0,t._)("span",{class:"mord mathnormal"},"x"),(0,t._)("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),(0,t._)("span",{class:"mrel"},"="),(0,t._)("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),(0,t._)("span",{class:"base"},[(0,t._)("span",{class:"strut",style:{height:"1.1901em","vertical-align":"-0.345em"}}),(0,t._)("span",{class:"mord"},[(0,t._)("span",{class:"mopen nulldelimiter"}),(0,t._)("span",{class:"mfrac"},[(0,t._)("span",{class:"vlist-t vlist-t2"},[(0,t._)("span",{class:"vlist-r"},[(0,t._)("span",{class:"vlist",style:{height:"0.8451em"}},[(0,t._)("span",{style:{top:"-2.655em"}},[(0,t._)("span",{class:"pstrut",style:{height:"3em"}}),(0,t._)("span",{class:"sizing reset-size6 size3 mtight"},[(0,t._)("span",{class:"mord mtight"},[(0,t._)("span",{class:"mord mathnormal mtight"},"m")])])]),(0,t._)("span",{style:{top:"-3.23em"}},[(0,t._)("span",{class:"pstrut",style:{height:"3em"}}),(0,t._)("span",{class:"frac-line",style:{"border-bottom-width":"0.04em"}})]),(0,t._)("span",{style:{top:"-3.394em"}},[(0,t._)("span",{class:"pstrut",style:{height:"3em"}}),(0,t._)("span",{class:"sizing reset-size6 size3 mtight"},[(0,t._)("span",{class:"mord mtight"},[(0,t._)("span",{class:"mord mtight"},"1")])])])]),(0,t._)("span",{class:"vlist-s"},"​")]),(0,t._)("span",{class:"vlist-r"},[(0,t._)("span",{class:"vlist",style:{height:"0.345em"}},[(0,t._)("span")])])])]),(0,t._)("span",{class:"mclose nulldelimiter"})]),(0,t._)("span",{class:"mord cjk_fallback"},"（"),(0,t._)("span",{class:"mord mathnormal"},"x"),(0,t._)("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),(0,t._)("span",{class:"mrel"},"→"),(0,t._)("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),(0,t._)("span",{class:"base"},[(0,t._)("span",{class:"strut",style:{height:"0.6833em"}}),(0,t._)("span",{class:"mord"},"0"),(0,t._)("span",{class:"mord cjk_fallback"},"）")])])]),(0,t.Uk)(" 则有，")],-1),W=(0,t._)("p",null,[(0,t._)("img",{src:"https://cdn.jsdelivr.net/gh/thinkingme/thinkingme.github.io@master/images/collection/hashmap-loadfactor-08.png",alt:"",loading:"lazy"})],-1),R=(0,t._)("p",null,"所以，",-1),Z=(0,t._)("p",null,[(0,t._)("img",{src:"https://cdn.jsdelivr.net/gh/thinkingme/thinkingme.github.io@master/images/collection/hashmap-loadfactor-09.png",alt:"",loading:"lazy"})],-1),G=(0,t.Uk)("考虑到 HashMap 的容量有一个要求：它必须是 2 的 n 次幂（这个"),Q={href:"https://mp.weixin.qq.com/s/aS2dg4Dj1Efwujmv-6YTBg",target:"_blank",rel:"noopener noreferrer"},$=(0,t.Uk)("之前的文章"),nn=(0,t.Uk)("讲过了，点击链接回去可以再温故一下）。当加载因子选择了 0.75 就可以保证它与容量的乘积为整数。"),sn=(0,t.uE)('<div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>16*0.75=12\n32*0.75=24\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>除了 0.75，0.5~1 之间还有 0.625（5/8）、0.875（7/8）可选，从中位数的角度，挑 0.75 比较完美。另外，维基百科上说，拉链法（解决哈希冲突的一种）的加载因子最好限制在 0.7-0.8 以下，超过 0.8，查表时的 CPU 缓存不命中（cache missing）会按照指数曲线上升。</p><p>综上，0.75 是个比较完美的选择。</p><h2 id="四、线程不安全" tabindex="-1"><a class="header-anchor" href="#四、线程不安全" aria-hidden="true">#</a> 四、线程不安全</h2><p>三方面原因：多线程下扩容会死循环、多线程下 put 会导致元素丢失、put 和 get 并发时会导致 get 到 null，我们来一一分析。</p><h3 id="_01、多线程下扩容会死循环" tabindex="-1"><a class="header-anchor" href="#_01、多线程下扩容会死循环" aria-hidden="true">#</a> 01、多线程下扩容会死循环</h3><p>众所周知，HashMap 是通过拉链法来解决哈希冲突的，也就是当哈希冲突时，会将相同哈希值的键值对通过链表的形式存放起来。</p><p>JDK 7 时，采用的是头部插入的方式来存放链表的，也就是下一个冲突的键值对会放在上一个键值对的前面（同一位置上的新元素被放在链表的头部）。扩容的时候就有可能导致出现环形链表，造成死循环。</p><p>resize 方法的源码：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// newCapacity为新的容量</span>\n<span class="token keyword">void</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token keyword">int</span> newCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 小数组，临时过度下</span>\n    <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> oldTable <span class="token operator">=</span> table<span class="token punctuation">;</span>\n    <span class="token comment">// 扩容前的容量</span>\n    <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> oldTable<span class="token punctuation">.</span>length<span class="token punctuation">;</span>\n    <span class="token comment">// MAXIMUM_CAPACITY 为最大容量，2 的 30 次方 = 1&lt;&lt;30</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">==</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 容量调整为 Integer 的最大值 0x7fffffff（十六进制）=2 的 31 次方-1</span>\n        threshold <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>\n        <span class="token keyword">return</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token comment">// 初始化一个新的数组（大容量）</span>\n    <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span>newCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span>\n    <span class="token comment">// 把小数组的元素转移到大数组中</span>\n    <span class="token function">transfer</span><span class="token punctuation">(</span>newTable<span class="token punctuation">,</span> <span class="token function">initHashSeedAsNeeded</span><span class="token punctuation">(</span>newCapacity<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token comment">// 引用新的大数组</span>\n    table <span class="token operator">=</span> newTable<span class="token punctuation">;</span>\n    <span class="token comment">// 重新计算阈值</span>\n    threshold <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>newCapacity <span class="token operator">*</span> loadFactor<span class="token punctuation">,</span> MAXIMUM_CAPACITY <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>transfer 方法用来转移，将小数组的元素拷贝到新的数组中。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTable<span class="token punctuation">,</span> <span class="token keyword">boolean</span> rehash<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 新的容量</span>\n    <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> newTable<span class="token punctuation">.</span>length<span class="token punctuation">;</span>\n    <span class="token comment">// 遍历小数组</span>\n    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e <span class="token operator">:</span> table<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">!=</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token comment">// 拉链法，相同 key 上的不同值</span>\n            <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>\n            <span class="token comment">// 是否需要重新计算 hash</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>rehash<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                e<span class="token punctuation">.</span>hash <span class="token operator">=</span> <span class="token keyword">null</span> <span class="token operator">==</span> e<span class="token punctuation">.</span>key <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token function">hash</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n            <span class="token comment">// 根据大数组的容量，和键的 hash 计算元素在数组中的下标</span>\n            <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n            <span class="token comment">// 同一位置上的新元素被放在链表的头部</span>\n            e<span class="token punctuation">.</span>next <span class="token operator">=</span> newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>\n\n            <span class="token comment">// 放在新的数组上</span>\n            newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>\n\n            <span class="token comment">// 链表上的下一个元素</span>\n            e <span class="token operator">=</span> next<span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意 <code>e.next = newTable[i]</code> 和 <code>newTable[i] = e</code> 这两行代码，就会将同一位置上的新元素被放在链表的头部。</p><p>扩容前的样子假如是下面这样子。</p><p><img src="https://cdn.jsdelivr.net/gh/thinkingme/thinkingme.github.io@master/images/collection/hashmap-thread-nosafe-01.png" alt="" loading="lazy"></p><p>那么正常扩容后就是下面这样子。</p><p><img src="https://cdn.jsdelivr.net/gh/thinkingme/thinkingme.github.io@master/images/collection/hashmap-thread-nosafe-02.png" alt="" loading="lazy"></p><p>假设现在有两个线程同时进行扩容，线程 A 在执行到 <code>newTable[i] = e;</code> 被挂起，此时线程 A 中：e=3、next=7、e.next=null</p><p><img src="https://cdn.jsdelivr.net/gh/thinkingme/thinkingme.github.io@master/images/collection/hashmap-thread-nosafe-03.png" alt="" loading="lazy"></p><p>线程 B 开始执行，并且完成了数据转移。</p><p><img src="https://cdn.jsdelivr.net/gh/thinkingme/thinkingme.github.io@master/images/collection/hashmap-thread-nosafe-04.png" alt="" loading="lazy"></p><p>此时，7 的 next 为 3，3 的 next 为 null。</p><p>随后线程 A 获得 CPU 时间片继续执行 <code>newTable[i] = e</code>，将 3 放入新数组对应的位置，执行完此轮循环后线程 A 的情况如下：</p><p><img src="https://cdn.jsdelivr.net/gh/thinkingme/thinkingme.github.io@master/images/collection/hashmap-thread-nosafe-05.png" alt="" loading="lazy"></p><p>执行下一轮循环，此时 e=7，原本线程 A 中 7 的 next 为 5，但由于 table 是线程 A 和线程 B 共享的，而线程 B 顺利执行完后，7 的 next 变成了 3，那么此时线程 A 中，7 的 next 也为 3 了。</p><p>采用头部插入的方式，变成了下面这样子：</p><p><img src="https://cdn.jsdelivr.net/gh/thinkingme/thinkingme.github.io@master/images/collection/hashmap-thread-nosafe-06.png" alt="" loading="lazy"></p><p>好像也没什么问题，此时 next = 3，e = 3。</p><p>进行下一轮循环，但此时，由于线程 B 将 3 的 next 变为了 null，所以此轮循环应该是最后一轮了。</p><p>接下来当执行完 <code>e.next=newTable[i]</code> 即 3.next=7 后，3 和 7 之间就相互链接了，执行完 <code>newTable[i]=e</code> 后，3 被头插法重新插入到链表中，执行结果如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/thinkingme/thinkingme.github.io@master/images/collection/hashmap-thread-nosafe-07.png" alt="" loading="lazy"></p><p>套娃开始，元素 5 也就成了弃婴，惨~~~</p>',32),an=(0,t.Uk)("不过，JDK 8 时已经修复了这个问题，扩容时会保持链表原来的顺序，参照"),tn={href:"https://mp.weixin.qq.com/s/0KSpdBJMfXSVH63XadVdmw",target:"_blank",rel:"noopener noreferrer"},pn=(0,t.Uk)("HashMap 扩容机制"),en=(0,t.Uk)("的这一篇。"),ln=(0,t.uE)('<h3 id="_02、多线程下-put-会导致元素丢失" tabindex="-1"><a class="header-anchor" href="#_02、多线程下-put-会导致元素丢失" aria-hidden="true">#</a> 02、多线程下 put 会导致元素丢失</h3><p>正常情况下，当发生哈希冲突时，HashMap 是这样的：</p><p><img src="https://cdn.jsdelivr.net/gh/thinkingme/thinkingme.github.io@master/images/collection/hashmap-thread-nosafe-08.png" alt="" loading="lazy"></p><p>但多线程同时执行 put 操作时，如果计算出来的索引位置是相同的，那会造成前一个 key 被后一个 key 覆盖，从而导致元素的丢失。</p><p>put 的源码：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span>\n               <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">;</span>\n\n    <span class="token comment">// 步骤①：tab为空则创建</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>\n        n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>\n\n    <span class="token comment">// 步骤②：计算index，并对null做处理</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>\n        tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">else</span> <span class="token punctuation">{</span>\n        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span> <span class="token class-name">K</span> k<span class="token punctuation">;</span>\n\n        <span class="token comment">// 步骤③：节点key存在，直接覆盖value</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>\n            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n            e <span class="token operator">=</span> p<span class="token punctuation">;</span>\n\n        <span class="token comment">// 步骤④：判断该链为红黑树</span>\n        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>\n            e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token comment">// 步骤⑤：该链为链表</span>\n        <span class="token keyword">else</span> <span class="token punctuation">{</span>\n            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                    p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n                    <span class="token comment">//链表长度大于8转换为红黑树进行处理</span>\n                    <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">&gt;=</span> TREEIFY_THRESHOLD <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// -1 for 1st</span>\n                        <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>\n                    <span class="token keyword">break</span><span class="token punctuation">;</span>\n                <span class="token punctuation">}</span>\n\n                <span class="token comment">// key已经存在直接覆盖value</span>\n                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>\n                    <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n                    <span class="token keyword">break</span><span class="token punctuation">;</span>\n                p <span class="token operator">=</span> e<span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n\n        <span class="token comment">// 步骤⑥、直接覆盖</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// existing mapping for key</span>\n            <span class="token class-name">V</span> oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>\n                e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>\n            <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n    <span class="token operator">++</span>modCount<span class="token punctuation">;</span>\n\n    <span class="token comment">// 步骤⑦：超过最大容量 就扩容</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">&gt;</span> threshold<span class="token punctuation">)</span>\n        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>问题发生在步骤 ② 这里：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>\n    tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>两个线程都执行了 if 语句，假设线程 A 先执行了 <code> tab[i] = newNode(hash, key, value, null)</code>，那 table 是这样的：</p><p><img src="https://cdn.jsdelivr.net/gh/thinkingme/thinkingme.github.io@master/images/collection/hashmap-thread-nosafe-09.png" alt="" loading="lazy"></p><p>接着，线程 B 执行了 <code> tab[i] = newNode(hash, key, value, null)</code>，那 table 是这样的：</p><p><img src="https://cdn.jsdelivr.net/gh/thinkingme/thinkingme.github.io@master/images/collection/hashmap-thread-nosafe-10.png" alt="" loading="lazy"></p><p>3 被干掉了。</p><h3 id="_03、put-和-get-并发时会导致-get-到-null" tabindex="-1"><a class="header-anchor" href="#_03、put-和-get-并发时会导致-get-到-null" aria-hidden="true">#</a> 03、put 和 get 并发时会导致 get 到 null</h3><p>线程 A 执行 put 时，因为元素个数超出阈值而出现扩容，线程 B 此时执行 get，有可能导致这个问题。</p><p>注意来看 resize 源码：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> oldTab <span class="token operator">=</span> table<span class="token punctuation">;</span>\n    <span class="token keyword">int</span> oldCap <span class="token operator">=</span> <span class="token punctuation">(</span>oldTab <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> oldTab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>\n    <span class="token keyword">int</span> oldThr <span class="token operator">=</span> threshold<span class="token punctuation">;</span>\n    <span class="token keyword">int</span> newCap<span class="token punctuation">,</span> newThr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">&gt;=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            threshold <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>\n            <span class="token keyword">return</span> oldTab<span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        <span class="token comment">// 没超过最大值，就扩充为原来的2倍</span>\n        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newCap <span class="token operator">=</span> oldCap <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span>\n                 oldCap <span class="token operator">&gt;=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span>\n            newThr <span class="token operator">=</span> oldThr <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// double threshold</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldThr <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// initial capacity was placed in threshold</span>\n        newCap <span class="token operator">=</span> oldThr<span class="token punctuation">;</span>\n    <span class="token keyword">else</span> <span class="token punctuation">{</span>               <span class="token comment">// zero initial threshold signifies using defaults</span>\n        newCap <span class="token operator">=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">;</span>\n        newThr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>DEFAULT_LOAD_FACTOR <span class="token operator">*</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token comment">// 计算新的resize上限</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>newThr <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">float</span> ft <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>newCap <span class="token operator">*</span> loadFactor<span class="token punctuation">;</span>\n        newThr <span class="token operator">=</span> <span class="token punctuation">(</span>newCap <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span> ft <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>MAXIMUM_CAPACITY <span class="token operator">?</span>\n                  <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>ft <span class="token operator">:</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    threshold <span class="token operator">=</span> newThr<span class="token punctuation">;</span>\n    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">&quot;rawtypes&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;unchecked&quot;</span><span class="token punctuation">}</span><span class="token punctuation">)</span>\n        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTab <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>newCap<span class="token punctuation">]</span><span class="token punctuation">;</span>\n    table <span class="token operator">=</span> newTab<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>线程 A 执行完 <code>table = newTab</code> 之后，线程 B 中的 table 此时也发生了变化，此时去 get 的时候当然会 get 到 null 了，因为元素还没有转移。</p><p>参考链接：</p>',19),on={href:"https://blog.csdn.net/lonyw/article/details/80519652",target:"_blank",rel:"noopener noreferrer"},cn=(0,t.Uk)("https://blog.csdn.net/lonyw/article/details/80519652"),un={href:"https://zhuanlan.zhihu.com/p/91636401",target:"_blank",rel:"noopener noreferrer"},rn=(0,t.Uk)("https://zhuanlan.zhihu.com/p/91636401"),kn={href:"https://www.zhihu.com/question/20733617",target:"_blank",rel:"noopener noreferrer"},dn=(0,t.Uk)("https://www.zhihu.com/question/20733617"),mn={href:"https://zhuanlan.zhihu.com/p/21673805",target:"_blank",rel:"noopener noreferrer"},hn=(0,t.Uk)("https://zhuanlan.zhihu.com/p/21673805"),vn=(0,t._)("p",null,[(0,t._)("img",{src:"https://cdn.jsdelivr.net/gh/thinkingme/thinkingme.github.io@master/images/xingbiaogongzhonghao.png",alt:"",loading:"lazy"})],-1),gn={},bn=(0,a(13860).Z)(gn,[["render",function(n,s){const a=(0,t.up)("ExternalLinkIcon");return(0,t.wg)(),(0,t.iD)("div",null,[p,e,l,o,c,i,(0,t._)("p",null,[u,(0,t._)("a",r,[k,(0,t.Wm)(a)]),d]),m,(0,t._)("p",null,[h,(0,t._)("a",v,[g,(0,t.Wm)(a)]),b]),_,y,w,f,x,(0,t._)("p",null,[M,T,z,(0,t._)("a",A,[C,(0,t.Wm)(a)]),j]),U,(0,t._)("blockquote",null,[(0,t._)("p",null,[I,(0,t._)("a",N,[V,(0,t.Wm)(a)])])]),K,(0,t._)("blockquote",null,[(0,t._)("p",null,[L,(0,t._)("a",E,[H,(0,t.Wm)(a)])])]),q,D,X,P,J,Y,F,O,B,S,W,R,Z,(0,t._)("p",null,[G,(0,t._)("a",Q,[$,(0,t.Wm)(a)]),nn]),sn,(0,t._)("p",null,[an,(0,t._)("a",tn,[pn,(0,t.Wm)(a)]),en]),ln,(0,t._)("blockquote",null,[(0,t._)("ul",null,[(0,t._)("li",null,[(0,t._)("a",on,[cn,(0,t.Wm)(a)])]),(0,t._)("li",null,[(0,t._)("a",un,[rn,(0,t.Wm)(a)])]),(0,t._)("li",null,[(0,t._)("a",kn,[dn,(0,t.Wm)(a)])]),(0,t._)("li",null,[(0,t._)("a",mn,[hn,(0,t.Wm)(a)])])])]),vn])}]])},13860:(n,s)=>{s.Z=(n,s)=>{const a=n.__vccOpts||n;for(const[n,t]of s)a[n]=t;return a}}}]);