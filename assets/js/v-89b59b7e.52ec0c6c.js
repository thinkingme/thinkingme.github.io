"use strict";(self.webpackChunkcoding_road=self.webpackChunkcoding_road||[]).push([[8994],{69338:(e,i,d)=>{d.r(i),d.d(i,{data:()=>n});const n={key:"v-89b59b7e",path:"/coding-road/javaee/dev-tools/packaging-tool/gradle/dependencies.html",title:"gradle依赖",lang:"zh-CN",frontmatter:{summary:"gradle依赖 依赖类型 dependencies DSL标签是标准Gradle API中的一部分，而不是Android Gradle插件的特性，所以它不属于android标签。 依赖有三种方式，如下面的例子： 1. 本地library模块依赖 这种依赖方式是直接依赖本地库工程代码的（需要注意的是，mylibrary的名字必须匹配在settings.gra",head:[["meta",{property:"og:url",content:"https://vuepress-theme-hope-v2-demo.mrhope.site/coding-road/javaee/dev-tools/packaging-tool/gradle/dependencies.html"}],["meta",{property:"og:site_name",content:"coding-rode"}],["meta",{property:"og:title",content:"gradle依赖"}],["meta",{property:"og:type",content:"article"}],["meta",{property:"og:updated_time",content:"2022-11-04T02:33:31.000Z"}],["meta",{property:"og:locale",content:"zh-CN"}],["meta",{property:"article:modified_time",content:"2022-11-04T02:33:31.000Z"}]]},excerpt:"",headers:[{level:2,title:"依赖类型",slug:"依赖类型",children:[{level:3,title:"1. 本地library模块依赖",slug:"_1-本地library模块依赖",children:[]},{level:3,title:"2. 本地二进制依赖",slug:"_2-本地二进制依赖",children:[]},{level:3,title:"3. 远程二进制依赖",slug:"_3-远程二进制依赖",children:[]}]},{level:2,title:"依赖配置",slug:"依赖配置",children:[]},{level:2,title:"查看依赖树",slug:"查看依赖树",children:[]},{level:2,title:"如何排除依赖",slug:"如何排除依赖",children:[{level:3,title:"1、dependencies中排除（细粒度）",slug:"_1、dependencies中排除-细粒度",children:[]},{level:3,title:"2、全局配置排除",slug:"_2、全局配置排除",children:[]},{level:3,title:"3、禁用依赖传递",slug:"_3、禁用依赖传递",children:[]},{level:3,title:"4、强制使用某个版本",slug:"_4、强制使用某个版本",children:[]},{level:3,title:"5、在打包时排除依赖",slug:"_5、在打包时排除依赖",children:[]}]}],git:{createdTime:1667529211e3,updatedTime:1667529211e3,contributors:[{name:"thinkingme",email:"linzhenhuigg@gmail.com",commits:1}]},readingTime:{minutes:4.84,words:1452},filePathRelative:"coding-road/javaee/dev-tools/packaging-tool/gradle/dependencies.md"}},54040:(e,i,d)=>{d.r(i),d.d(i,{default:()=>t});var n=d(95393);const l=[(0,n.uE)('<h1 id="gradle依赖" tabindex="-1"><a class="header-anchor" href="#gradle依赖" aria-hidden="true">#</a> gradle依赖</h1><h2 id="依赖类型" tabindex="-1"><a class="header-anchor" href="#依赖类型" aria-hidden="true">#</a> 依赖类型</h2><p>dependencies DSL标签是标准Gradle API中的一部分，而不是Android Gradle插件的特性，所以它不属于android标签。</p><p>依赖有三种方式，如下面的例子：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>apply plugin: &#39;com.android.application&#39;\n\nandroid { ... }\n\ndependencies {\n    // Dependency on a local library module\n    implementation project(&quot;:mylibrary&quot;)\n\n    // Dependency on local binaries\n    implementation fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;])\n\n    // Dependency on a remote binary\n    implementation &#39;com.example.android:app-magic:12.3&#39;\n}\n复制代码\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_1-本地library模块依赖" tabindex="-1"><a class="header-anchor" href="#_1-本地library模块依赖" aria-hidden="true">#</a> 1. 本地library模块依赖</h3><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>implementation project(&quot;:mylibrary&quot;)\n\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这种依赖方式是直接依赖本地库工程代码的（需要注意的是，mylibrary的名字必须匹配在<code>settings.gradle</code>中include标签下定义的模块名字）。</p><h3 id="_2-本地二进制依赖" tabindex="-1"><a class="header-anchor" href="#_2-本地二进制依赖" aria-hidden="true">#</a> 2. 本地二进制依赖</h3><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>implementation fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;])\n\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这种依赖方式是依赖工程中的 <code>module_name/libs/目录下的Jar文件</code>（注意Gradle的路径是相对于build.gradle文件来读取的，所以上面是这样的相对路径）。</p><p>如果只想依赖单个特定本地二进制库，可以如下配置：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>implementation files(&#39;libs/foo.jar&#39;, &#39;libs/bar.jar&#39;)\n\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-远程二进制依赖" tabindex="-1"><a class="header-anchor" href="#_3-远程二进制依赖" aria-hidden="true">#</a> 3. 远程二进制依赖</h3><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>implementation &#39;com.example.android:app-magic:12.3&#39;\n\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面是简写的方式，这种依赖完整的写法如下：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>implementation group: &#39;com.example.android&#39;, name: &#39;app-magic&#39;, version: &#39;12.3&#39;\n\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>group</code>、<code>name</code>、<code>version</code> 共同定位一个远程依赖库。需要注意的点是，<code>version</code> 最好不要写成&quot;12.3+&quot;这种方式，除非有明确的预期，因为非预期的版本更新会带来构建问题。远程依赖需要在<code>repositories</code>标签下声明远程仓库，例如<code>jcenter()</code>、<code>google()</code>、<code>maven</code>仓库等。</p><h2 id="依赖配置" tabindex="-1"><a class="header-anchor" href="#依赖配置" aria-hidden="true">#</a> 依赖配置</h2><p>目前Gradle版本支持的依赖配置有：<code>implementation</code>、<code>api</code>、<code>compileOnly</code>、<code>runtimeOnly</code> 和 <code>annotationProcessor</code>，已经废弃的配置有：<code>compile</code>、<code>provided</code>、<code>apk</code>、<code>providedCompile</code>。此外依赖配置还可以加一些配置项，例如<code>AndroidTestImplementation</code>、<code>debugApi</code>等等。</p><p>常用的是<code>implementation</code>、<code>api</code>、<code>compileOnly</code>三个依赖配置，含义如下：</p><table><thead><tr><th style="text-align:left;">配置名称</th><th style="text-align:left;">描述</th></tr></thead><tbody><tr><td style="text-align:left;"><code>api</code></td><td style="text-align:left;">与compile对应，功能完全一样，会添加依赖到编译路径，并且会将依赖打包到输出（aar或apk），与implementation不同，这个依赖可以传递，其他module无论在编译时和运行时都可以访问这个依赖的实现，也就是会泄漏一些不应该不使用的实现。举个例子，A依赖B，B依赖C，如果都是使用api配置的话，A可以直接使用C中的类（编译时和运行时），而如果是使用implementation配置的话，在编译时，A是无法访问C中的类的。</td></tr><tr><td style="text-align:left;"><code>implementation</code></td><td style="text-align:left;">与compile对应，会添加依赖到编译路径，并且会将依赖打包到输出（aar或apk），但是在编译时不会将依赖的实现暴露给其他module，也就是只有在运行时其他module才能访问这个依赖中的实现。使用这个配置，可以显著提升构建时间，因为它可以减少重新编译的module的数量。建议，尽量使用这个依赖配置。</td></tr><tr><td style="text-align:left;"><code>compileOnly</code></td><td style="text-align:left;">与provided对应，Gradle把依赖加到编译路径，编译时使用，不会打包到输出（aar或apk）。这可以减少输出的体积，在只在编译时需要，在运行时可选的情况，很有用。例如lombok</td></tr><tr><td style="text-align:left;"><code>compileOnlyApi</code>（6.7后添加入java-library插件）</td><td style="text-align:left;">在compileOnly之上，加上api，表示这是可以被传递的。</td></tr><tr><td style="text-align:left;"><code>annotationProcessor</code></td><td style="text-align:left;">与compile对应，用于注解处理器的依赖配置，这个没用过。</td></tr><tr><td style="text-align:left;"><code>runtimeOnly</code></td><td style="text-align:left;">与apk对应，gradle添加依赖只打包到APK，运行时使用，但不会添加到编译路径。这个没有使用过。</td></tr><tr><td style="text-align:left;"><code>testImplementation</code></td><td style="text-align:left;">这是您声明用于编译测试的依赖项的地方。</td></tr><tr><td style="text-align:left;"><code>testCompileOnly</code></td><td style="text-align:left;">这是您声明依赖项的地方，这些依赖项仅在测试编译时需要，但不应泄漏到运行时。这通常包括在运行时发现时被遮蔽的依赖项。</td></tr><tr><td style="text-align:left;"><code>testRuntimeOnly</code></td><td style="text-align:left;">这是您声明依赖项的地方，这些依赖项仅在测试运行时需要，而不是在测试编译时需要。</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;"></td></tr></tbody></table><blockquote><p>api/compile 的依赖会被传递，注意有些依赖可能是公共管理版本的</p></blockquote><h2 id="查看依赖树" tabindex="-1"><a class="header-anchor" href="#查看依赖树" aria-hidden="true">#</a> 查看依赖树</h2><p>可以查看单个module或者这个project的依赖，通过运行依赖的Gradle任务，如下：</p><p>1、<code>View</code> -&gt; <code>Tools Windows</code> -&gt; <code>Gradle</code>（<code>或者点击右侧的Gradle栏</code>）；</p><p>2、展开 <code>AppName</code> -&gt; <code>Tasks</code> -&gt; <code>android</code>，然后双击运行<code>AndroidDependencies</code>。运行完，就会在Run窗口打出依赖树了。</p><h2 id="如何排除依赖" tabindex="-1"><a class="header-anchor" href="#如何排除依赖" aria-hidden="true">#</a> 如何排除依赖</h2><h3 id="_1、dependencies中排除-细粒度" tabindex="-1"><a class="header-anchor" href="#_1、dependencies中排除-细粒度" aria-hidden="true">#</a> <strong>1、dependencies中排除（细粒度）</strong></h3><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>compile(&#39;com.taobao.android:accs-huawei:1.1.2@aar&#39;) {\n        transitive = true\n        exclude group: &#39;com.taobao.android&#39;, module: &#39;accs_sdk_taobao&#39;\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2、全局配置排除" tabindex="-1"><a class="header-anchor" href="#_2、全局配置排除" aria-hidden="true">#</a> <strong>2、全局配置排除</strong></h3><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>configurations {\n    compile.exclude module: &#39;cglib&#39;\n    //全局排除原有的tnet jar包与so包分离的配置，统一使用aar包中的内容\n    all*.exclude group: &#39;com.taobao.android&#39;, module: &#39;tnet-jni&#39;\n    all*.exclude group: &#39;com.taobao.android&#39;, module: &#39;tnet-so&#39;\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3、禁用依赖传递" tabindex="-1"><a class="header-anchor" href="#_3、禁用依赖传递" aria-hidden="true">#</a> <strong>3、禁用依赖传递</strong></h3><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>compile(&#39;com.zhyea:ar4j:1.0&#39;) {\n    transitive = false\n}\n\nconfigurations.all {\n    transitive = false\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>还可以在单个依赖项中使用@jar标识符忽略传递依赖：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>compile &#39;com.zhyea:ar4j:1.0@jar&#39;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="_4、强制使用某个版本" tabindex="-1"><a class="header-anchor" href="#_4、强制使用某个版本" aria-hidden="true">#</a> <strong>4、强制使用某个版本</strong></h3><p>如果某个依赖项是必需的，而又存在依赖冲突时，此时没必要逐个进行排除，可以使用<code>force</code>属性标识需要进行依赖统一。当然这也是可以全局配置的：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>compile(&#39;com.zhyea:ar4j:1.0&#39;) {\n    force = true\n}\n\nconfigurations.all {\n    resolutionStrategy {\n        force &#39;org.hamcrest:hamcrest-core:1.3&#39;\n    }\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_5、在打包时排除依赖" tabindex="-1"><a class="header-anchor" href="#_5、在打包时排除依赖" aria-hidden="true">#</a> <strong>5、在打包时排除依赖</strong></h3><p>先看一个示例：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>task zip(type: Zip) {\n    into(&#39;lib&#39;) {\n        from(configurations.runtime) {\n            exclude &#39;*unwanted*&#39;, &#39;*log*&#39;\n        }\n    }\n    into(&#39;&#39;) {\n        from jar\n        from &#39;doc&#39;\n    }\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>代码表示在打zip包的时候会过滤掉名称中包含<code>“unwanted”</code>和<code>“log”</code>的jar包。这里调用的exclude方法的参数和前面的例子不太一样，前面的参数多是map结构，这里则是一个正则表达式字符串。</p><p>也可以使用在打包时调用include方法选择只打包某些需要的依赖项：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>task zip(type: Zip) {\n    into(&#39;lib&#39;) {\n        from(configurations.runtime) {\n            include &#39;*ar4j*&#39;, &#39;*spring*&#39;\n        }\n    }\n    into(&#39;&#39;) {\n        from jar\n        from &#39;doc&#39;\n    }\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>主要是使用dependencies中排除和全局配置排除。</p>',46)],a={},t=(0,d(13860).Z)(a,[["render",function(e,i){return(0,n.wg)(),(0,n.iD)("div",null,l)}]])},13860:(e,i)=>{i.Z=(e,i)=>{const d=e.__vccOpts||e;for(const[e,n]of i)d[e]=n;return d}}}]);