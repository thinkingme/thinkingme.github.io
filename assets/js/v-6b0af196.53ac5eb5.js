"use strict";(self.webpackChunkcoding_road=self.webpackChunkcoding_road||[]).push([[3940],{40234:(e,n,a)=>{a.r(n),a.d(n,{data:()=>s});const s={key:"v-6b0af196",path:"/coding-road/network/LVS.html",title:"LVS负载均衡策略",lang:"zh-CN",frontmatter:{summary:"LVS负载均衡策略 前置知识 先看看网络那篇了解大概的网络知识。 进阶知识 linux路由配置 假设我们有上图网络配置的两台linux虚拟机，正常网工应该会在路由器中配置各个网络。这里为了起到学习的目的，我们可以用linux的路由表来模拟。 首先我们在13机子上面创建一个新的网卡 此时13的路由条目如下图： 如果想要14机子能访问到这块网卡(ping 192",head:[["meta",{property:"og:url",content:"https://vuepress-theme-hope-v2-demo.mrhope.site/coding-road/network/LVS.html"}],["meta",{property:"og:site_name",content:"coding-rode"}],["meta",{property:"og:title",content:"LVS负载均衡策略"}],["meta",{property:"og:type",content:"article"}],["meta",{property:"og:updated_time",content:"2022-12-13T02:10:16.000Z"}],["meta",{property:"og:locale",content:"zh-CN"}],["meta",{property:"article:modified_time",content:"2022-12-13T02:10:16.000Z"}]]},excerpt:"",headers:[{level:2,title:"前置知识",slug:"前置知识",children:[]},{level:2,title:"进阶知识",slug:"进阶知识",children:[{level:3,title:"linux路由配置",slug:"linux路由配置",children:[]}]},{level:2,title:"概述",slug:"概述",children:[{level:3,title:"一、NAT模式（VS-NAT）",slug:"一、nat模式-vs-nat",children:[]},{level:3,title:"二、直接路由模式（VS-DR）",slug:"二、直接路由模式-vs-dr",children:[]},{level:3,title:"三、IP隧道模式（VS-TUN）",slug:"三、ip隧道模式-vs-tun",children:[]}]},{level:2,title:"实验",slug:"实验",children:[{level:3,title:"整体结构",slug:"整体结构",children:[]},{level:3,title:"实验步骤",slug:"实验步骤",children:[]},{level:3,title:"利用keepalive保证高可用",slug:"利用keepalive保证高可用",children:[]}]}],git:{createdTime:1670897416e3,updatedTime:1670897416e3,contributors:[{name:"thinkingme",email:"linzhenhuigg@gmail.com",commits:1}]},readingTime:{minutes:5.56,words:1668},filePathRelative:"coding-road/network/LVS.md"}},9845:(e,n,a)=>{a.r(n),a.d(n,{default:()=>t});var s=a(95393);const i=[(0,s.uE)('<h1 id="lvs负载均衡策略" tabindex="-1"><a class="header-anchor" href="#lvs负载均衡策略" aria-hidden="true">#</a> LVS负载均衡策略</h1><h2 id="前置知识" tabindex="-1"><a class="header-anchor" href="#前置知识" aria-hidden="true">#</a> 前置知识</h2><p>先看看网络那篇了解大概的网络知识。</p><h2 id="进阶知识" tabindex="-1"><a class="header-anchor" href="#进阶知识" aria-hidden="true">#</a> 进阶知识</h2><h3 id="linux路由配置" tabindex="-1"><a class="header-anchor" href="#linux路由配置" aria-hidden="true">#</a> linux路由配置</h3><p><img src="D:\\workspace\\coding-road\\images\\LVS\\2022-12-05-15-04-26-image.png" alt="" loading="lazy"></p><p>假设我们有上图网络配置的两台linux虚拟机，正常网工应该会在路由器中配置各个网络。这里为了起到学习的目的，我们可以用linux的路由表来模拟。</p><p>首先我们在13机子上面创建一个新的网卡</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">ifconfig</span> eth0:3 <span class="token number">192.168</span>.88.88/24\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>此时13的路由条目如下图：</p><p><img src="D:\\workspace\\coding-road\\images\\LVS\\2022-12-05-15-18-17-image.png" alt="" loading="lazy"></p><p>如果想要14机子能访问到这块网卡(ping 192.168.88.88)</p><p>要在14机子上配置一下路由</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>route <span class="token function">add</span> -host <span class="token number">192.168</span>.88.88 gw <span class="token number">192.168</span>.150.13\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><img src="D:\\workspace\\coding-road\\images\\LVS\\2022-12-05-15-14-01-image.png" alt="" loading="lazy"></p><p>意思就是把192.168.150.13这台linux当成了路由器。把去往88.88ip的数据包发给13,而13路由表中有关于88.88ip的配置，这样就实现了通信。</p><h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h2><h3 id="一、nat模式-vs-nat" tabindex="-1"><a class="header-anchor" href="#一、nat模式-vs-nat" aria-hidden="true">#</a> 一、NAT模式（VS-NAT）</h3><p>原理：就是把客户端发来的数据包的IP头的目的地址，在负载均衡器上换成其中一台RS的IP地址，并发至此RS来处理,RS处理完成后把数据交给经过负载均衡器,负载均衡器再把数据包的原IP地址改为自己的IP，将目的地址改为客户端IP地址即可期间,无论是进来的流量,还是出去的流量,都必须经过负载均衡器（即修改来去的目标IP和MAC地址）</p><p>优点：集群中的物理服务器可以使用任何支持TCP/IP操作系统，只有负载均衡器需要一个合法的IP地址。</p><p>缺点：扩展性有限。当服务器节点（普通PC服务器）数据增长到20个或更多时,负载均衡器将成为整个系统的瓶颈，因为所有的请求包和应答包都需要经过负载均衡器再生。假使TCP包的平均长度是536字节的话，平均包再生延迟时间大约为60us（在Pentium处理器上计算的，采用更快的处理器将使得这个延迟时间变短），负载均衡器的最大容许能力为8.93M/s，假定每台物理服务器的平台容许能力为400K/s来计算，负责均衡器能为22台物理服务器计算。</p><blockquote><p>据研究表明，客户端发送的数据包往往比服务器返回数据量小很多，所以出现了如下的负载模式，只对接受的数据进行负载，返回的数据包直接返回。这样变相增加了负载服务器的带宽。</p></blockquote><h3 id="二、直接路由模式-vs-dr" tabindex="-1"><a class="header-anchor" href="#二、直接路由模式-vs-dr" aria-hidden="true">#</a> 二、直接路由模式（VS-DR）</h3><p>原理：负载均衡器和RS都使用同一个IP对外服务但只有DR对ARP请求进行响应,所有RS对本身这个IP的ARP请求保持静默也就是说,网关会把对这个服务IP的请求全部定向给DR,而DR收到数据包后根据调度算法,找出对应的RS,把目的MAC地址改为RS的MAC（因为IP一致）并将请求分发给这台RS这时RS收到这个数据包,处理完成之后，由于IP一致，可以直接将数据返给客户，则等于直接从客户端收到这个数据包无异,处理后直接返回给客户端由于负载均衡器要对二层包头进行改换,所以负载均衡器和RS之间必须在一个广播域,也可以简单的理解为在同一台交换机上</p><p>优点：和TUN（隧道模式）一样，负载均衡器也只是分发请求，应答包通过单独的路由方法返回给客户端。与VS-TUN相比，VS-DR这种实现方式不需要隧道结构，因此可以使用大多数操作系统做为物理服务器。</p><p>缺点：（不能说缺点，只能说是不足）要求负载均衡器的网卡必须与物理网卡在一个物理段上。</p><h3 id="三、ip隧道模式-vs-tun" tabindex="-1"><a class="header-anchor" href="#三、ip隧道模式-vs-tun" aria-hidden="true">#</a> 三、IP隧道模式（VS-TUN）</h3><p>原理：首先要知道，互联网上的大多Internet服务的请求包很短小，而应答包通常很大。那么隧道模式就是，把客户端发来的数据包，封装一个新的IP头标记(仅目的IP)发给RS,RS收到后,先把数据包的头解开,还原数据包,处理后,直接返回给客户端,不需要再经过负载均衡器注意,由于RS需要对负载均衡器发过来的数据包进行还原,所以说必须支持IPTUNNEL协议所以,在RS的内核中,必须编译支持IPTUNNEL这个选项</p><p>优点：负载均衡器只负责将请求包分发给后端节点服务器，而RS将应答包直接发给用户。所以，减少了负载均衡器的大量数据流动，负载均衡器不再是系统的瓶颈，就能处理很巨大的请求量，这种方式，一台负载均衡器能够为很多RS进行分发。而且跑在公网上就能进行不同地域的分发。</p><p>缺点：隧道模式的RS节点需要合法IP，这种方式需要所有的服务器支持”IP Tunneling”(IP Encapsulation)协议，服务器可能只局限在部分Linux系统上。</p><h2 id="实验" tabindex="-1"><a class="header-anchor" href="#实验" aria-hidden="true">#</a> 实验</h2><h3 id="整体结构" tabindex="-1"><a class="header-anchor" href="#整体结构" aria-hidden="true">#</a> 整体结构</h3><p><img src="D:\\workspace\\coding-road\\images\\LVS\\2022-11-30-17-46-00-image.png" alt="" loading="lazy"></p><h3 id="实验步骤" tabindex="-1"><a class="header-anchor" href="#实验步骤" aria-hidden="true">#</a> 实验步骤</h3><p>node01：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">ifconfig</span> eht0:8 <span class="token number">192.168</span>.150.100/24\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>node 02~03 配置arp协议:</p><p><img src="D:\\workspace\\coding-road\\images\\LVS\\2022-12-06-14-31-28-image.png" alt="" loading="lazy"></p><ul><li>修改内核</li></ul><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token builtin class-name">echo</span> <span class="token number">1</span> <span class="token operator">&gt;</span> /proc/sys/net/ipv4/conf/eth0/arp_ignore \n<span class="token builtin class-name">echo</span> <span class="token number">1</span> <span class="token operator">&gt;</span> /proc/sys/net/ipv4/conf/all/arp_ignore\n<span class="token builtin class-name">echo</span> <span class="token number">2</span> <span class="token operator">&gt;</span> /proc/sys/net/ipv4/conf/all/arp_announce<span class="token comment">#配置为2不允许通告</span>\n<span class="token builtin class-name">echo</span> <span class="token number">2</span> <span class="token operator">&gt;</span> /proc/sys/net/ipv4/conf/all/arp_announce\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>设置隐藏的vip</li></ul><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">ifconfig</span> lo:3 <span class="token number">192.168</span>.150.100 netmask <span class="token number">255.255</span>.255.255\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>node02~03开启服务</li></ul><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>yum <span class="token function">install</span> httpd -y\n<span class="token function">service</span> httpd start\n<span class="token function">vi</span> /var/www/html/index.html <span class="token comment">#修改html页面的显示内容以区分负载到了哪台服务器</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>LVS服务配置</li></ul><p>node01：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>yum <span class="token function">install</span> ipvsadm  <span class="token comment">#下载lvs</span>\nipvsadm -A -t <span class="token number">192.168</span>.150.100:80 -s rr <span class="token comment">#配置</span>\nipvsadm -a -t <span class="token number">192.168</span>.150.100:80 -r <span class="token number">192.168</span>.150.12 -g -w <span class="token number">1</span><span class="token comment">#配置负载到node01</span>\nipvsadm -a -t <span class="token number">192.168</span>.150.100:80 -r <span class="token number">192.168</span>.150.13 -g -w <span class="token number">1</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>验证</li></ul><p>浏览器访问192.168.150.100 看到负载</p><p>node01：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">netstat</span> -natp <span class="token comment">#看不到建立了tcp连接</span>\nipvsadm -lnc <span class="token comment">#查看连接记录</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>node02~node03：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">netstat</span> -natp <span class="token comment">#看到建立了tcp连接</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="利用keepalive保证高可用" tabindex="-1"><a class="header-anchor" href="#利用keepalive保证高可用" aria-hidden="true">#</a> 利用keepalive保证高可用</h3>',54)],l={},t=(0,a(13860).Z)(l,[["render",function(e,n){return(0,s.wg)(),(0,s.iD)("div",null,i)}]])},13860:(e,n)=>{n.Z=(e,n)=>{const a=e.__vccOpts||e;for(const[e,s]of n)a[e]=s;return a}}}]);