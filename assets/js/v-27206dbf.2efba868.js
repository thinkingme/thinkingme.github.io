"use strict";(self.webpackChunkcoding_road=self.webpackChunkcoding_road||[]).push([[1462],{82713:(n,s,a)=>{a.r(s),a.d(s,{data:()=>t});const t={key:"v-27206dbf",path:"/coding-road/java-core/juc/condition.html",title:"深入理解 Java 并发线程协作类 Condition",lang:"zh-CN",frontmatter:{category:["Java核心","并发编程"],tag:["Java"],summary:"深入理解 Java 并发线程协作类 Condition Condition 简介 任何一个 java 对象都天然继承于 Object 类，在线程间实现通信的往往会应用到 Object 的几个方法： wait(); wait(long timeout); wait(long timeout, int nanos); notify(); notifyAll();",head:[["meta",{property:"og:url",content:"https://vuepress-theme-hope-v2-demo.mrhope.site/coding-road/java-core/juc/condition.html"}],["meta",{property:"og:site_name",content:"coding-rode"}],["meta",{property:"og:title",content:"深入理解 Java 并发线程协作类 Condition"}],["meta",{property:"og:type",content:"article"}],["meta",{property:"og:updated_time",content:"2022-06-04T08:56:49.000Z"}],["meta",{property:"og:locale",content:"zh-CN"}],["meta",{property:"article:tag",content:"Java"}],["meta",{property:"article:modified_time",content:"2022-06-04T08:56:49.000Z"}]]},excerpt:"",headers:[{level:2,title:"Condition 简介",slug:"condition-简介",children:[]},{level:2,title:"Condition 实现原理分析",slug:"condition-实现原理分析",children:[{level:3,title:"等待队列",slug:"等待队列",children:[]},{level:3,title:"await 实现原理",slug:"await-实现原理",children:[]},{level:3,title:"signal/signalAll 实现原理",slug:"signal-signalall-实现原理",children:[]}]},{level:2,title:"await 与 signal/signalAll 的结合思考",slug:"await-与-signal-signalall-的结合思考",children:[]},{level:2,title:"一个例子",slug:"一个例子",children:[]}],git:{createdTime:1653617096e3,updatedTime:1654333009e3,contributors:[{name:"林振辉",email:"linzhenhui@apexsoft.com",commits:2},{name:"thinkingme",email:"linzhenhuigg@gmail.com",commits:1}]},readingTime:{minutes:14.35,words:4306},filePathRelative:"coding-road/java-core/juc/condition.md"}},28468:(n,s,a)=>{a.r(s),a.d(s,{default:()=>v});var t=a(95393);const e=(0,t.uE)('<h1 id="深入理解-java-并发线程协作类-condition" tabindex="-1"><a class="header-anchor" href="#深入理解-java-并发线程协作类-condition" aria-hidden="true">#</a> 深入理解 Java 并发线程协作类 Condition</h1><h2 id="condition-简介" tabindex="-1"><a class="header-anchor" href="#condition-简介" aria-hidden="true">#</a> Condition 简介</h2><p>任何一个 java 对象都天然继承于 Object 类，在线程间实现通信的往往会应用到 Object 的几个方法：</p><ul><li>wait()</li><li>wait(long timeout)</li><li>wait(long timeout, int nanos)</li><li>notify()</li><li>notifyAll()</li></ul><p>同样的， 在 java Lock 体系下依然会有同样的方法实现等待/通知机制。</p><p>从整体上来看<strong>Object 的 wait 和 notify/notify 是与对象监视器配合完成线程间的等待/通知机制，而 Condition 与 Lock 配合完成等待通知机制，前者是 java 底层级别的，后者是语言级别的，具有更高的可控制性和扩展性</strong>。</p><p>两者除了在使用方式上不同外，在<strong>功能特性</strong>上还是有很多的不同：</p><ol><li>Condition 能够支持不响应中断，而通过使用 Object 方式不支持；</li><li>Condition 能够支持多个等待队列（new 多个 Condition 对象），而 Object 方式只能支持一个；</li><li>Condition 能够支持超时时间的设置，而 Object 不支持</li></ol><p>参照 Object 的 wait 和 notify/notifyAll 方法，Condition 也提供了同样的方法：</p><p><strong>针对 Object 的 wait 方法</strong></p><ol><li><code>void await() throws InterruptedException</code>:当前线程进入等待状态，如果其他线程调用 condition 的 signal 或者 signalAll 方法并且当前线程获取 Lock 从 await 方法返回，如果在等待状态中被中断会抛出被中断异常；</li><li><code>long awaitNanos(long nanosTimeout)</code>：当前线程进入等待状态直到被通知，中断或者<strong>超时</strong>；</li><li><code>boolean await(long time, TimeUnit unit)throws InterruptedException</code>：同第二种，支持自定义时间单位</li><li><code>boolean awaitUntil(Date deadline) throws InterruptedException</code>：当前线程进入等待状态直到被通知，中断或者<strong>到了某个时间</strong></li></ol><p><strong>针对 Object 的<code>notify/notifyAll</code>方法</strong></p><ol><li><code>void signal()</code>：唤醒一个等待在 condition 上的线程，将该线程从<strong>等待队列</strong>中转移到<strong>同步队列</strong>中，如果在同步队列中能够竞争到 Lock 则可以从等待方法中返回。</li><li><code>void signalAll()</code>：与 1 的区别在于能够唤醒所有等待在 condition 上的线程</li></ol><h2 id="condition-实现原理分析" tabindex="-1"><a class="header-anchor" href="#condition-实现原理分析" aria-hidden="true">#</a> Condition 实现原理分析</h2><h3 id="等待队列" tabindex="-1"><a class="header-anchor" href="#等待队列" aria-hidden="true">#</a> 等待队列</h3><p>要想能够深入的掌握 condition 还是应该知道它的实现原理，现在我们一起来看看 condiiton 的源码。</p><p>创建一个 condition 对象是通过<code>lock.newCondition()</code>,而这个方法实际上是会 new 出一个<strong>ConditionObject</strong>对象，该类是 AQS 的一个内部类。</p><p>前面我们说过，condition 是要和 lock 配合使用的也就是 condition 和 Lock 是绑定在一起的，而 lock 的实现原理又依赖于 AQS，自然而然 ConditionObject 就成为了 AQS 的一个内部类。</p><p>在锁机制的实现上，AQS 内部维护了一个同步队列，如果是独占式锁的话，所有获取锁失败的线程的尾插入到<strong>同步队列</strong>，同样的，condition 内部也是使用同样的方式，内部维护了一个 <strong>等待队列</strong>，所有调用 condition.await 方法的线程会加入到等待队列中，并且线程状态转换为等待状态。另外注意到 ConditionObject 中有两个成员变量：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token doc-comment comment">/** First node of condition queue. */</span>\n<span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">Node</span> firstWaiter<span class="token punctuation">;</span>\n<span class="token doc-comment comment">/** Last node of condition queue. */</span>\n<span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">Node</span> lastWaiter<span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样我们就可以看出来 ConditionObject 通过持有等待队列的头尾指针来管理等待队列。Node 类有这样一个属性：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">//后继节点</span>\n<span class="token class-name">Node</span> nextWaiter<span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>进一步说明，<strong>等待队列是一个单向队列</strong>，而在之前说 AQS 时知道同步队列是一个双向队列。接下来我们用一个 demo，通过 debug 进去看是不是符合我们的猜想：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>\n            lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword">try</span> <span class="token punctuation">{</span>\n                condition<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>\n                lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码没有任何实际意义，甚至很臭，只是想说明下我们刚才所想的。新建了 10 个线程，没有线程先获取锁，然后调用 condition.await 方法释放锁将当前线程加入到等待队列中，通过 debug 控制当走到第 10 个线程的时候查看<code>firstWaiter</code>即等待队列中的头结点，debug 模式下情景图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/thinkingme/thinkingme.github.io@master/images/thread/condition-01.png" alt="debug模式下情景图" loading="lazy"></p><p>从这个图我们可以很清楚的看到这样几点：</p><ol><li>调用 condition.await 方法后线程依次尾插入到等待队列中，如图队列中的线程引用依次为 Thread-0,Thread-1,Thread-2....Thread-8；</li><li>等待队列是一个单向队列。通过我们的猜想然后进行实验验证，我们可以得出等待队列的示意图如下图所示：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/thinkingme/thinkingme.github.io@master/images/thread/condition-02.png" alt="等待队列的示意图" loading="lazy"></p><p>同时还有一点需要注意的是：我们可以多次调用<code>lock.newCondition()</code>方法创建多个 condition 对象，也就是一个 lock 可以持有多个等待队列。</p><p>而在之前利用 Object 的方式实际上是指在<strong>对象 Object 对象监视器上只能拥有一个同步队列和一个等待队列，而并发包中的 Lock 拥有一个同步队列和多个等待队列</strong>。示意图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/thinkingme/thinkingme.github.io@master/images/thread/condition-03.png" alt="AQS持有多个Condition" loading="lazy"></p><p>如图所示，ConditionObject 是 AQS 的内部类，因此每个 ConditionObject 能够访问到 AQS 提供的方法，相当于每个 Condition 都拥有所属同步器的引用。</p><h3 id="await-实现原理" tabindex="-1"><a class="header-anchor" href="#await-实现原理" aria-hidden="true">#</a> await 实现原理</h3><p><strong>当调用<code>condition.await()</code>方法后会使得当前获取 lock 的线程进入到等待队列，如果该线程能够从 await()方法返回的话一定是该线程获取了与 condition 相关联的 lock</strong>。</p><p>接下来，我们还是从源码的角度去看，只有熟悉了源码的逻辑我们的理解才是最深的。await()方法源码为：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\t<span class="token comment">// 1. 将当前线程包装成Node，尾插入到等待队列中</span>\n    <span class="token class-name">Node</span> node <span class="token operator">=</span> <span class="token function">addConditionWaiter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\t<span class="token comment">// 2. 释放当前线程所占用的lock，在释放的过程中会唤醒同步队列中的下一个节点</span>\n    <span class="token keyword">int</span> savedState <span class="token operator">=</span> <span class="token function">fullyRelease</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">int</span> interruptMode <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isOnSyncQueue</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\t\t<span class="token comment">// 3. 当前线程进入到等待状态</span>\n        <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>interruptMode <span class="token operator">=</span> <span class="token function">checkInterruptWhileWaiting</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>\n            <span class="token keyword">break</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\t<span class="token comment">// 4. 自旋等待获取到同步状态（即获取到lock）</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">acquireQueued</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> savedState<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> interruptMode <span class="token operator">!=</span> THROW_IE<span class="token punctuation">)</span>\n        interruptMode <span class="token operator">=</span> REINTERRUPT<span class="token punctuation">;</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>nextWaiter <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// clean up if cancelled</span>\n        <span class="token function">unlinkCancelledWaiters</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\t<span class="token comment">// 5. 处理被中断的情况</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>interruptMode <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>\n        <span class="token function">reportInterruptAfterWait</span><span class="token punctuation">(</span>interruptMode<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>代码的主要逻辑<strong>请看注释</strong>，我们都知道<strong>当当前线程调用<code>condition.await()</code>方法后，会使得当前线程释放 lock 然后加入到等待队列中，直至被<code>signal/signalAll</code>后会使得当前线程从等待队列中移至到同步队列中去，直到获得了 lock 后才会从 await 方法返回，或者在等待时被中断会做中断处理</strong>。</p><p>那么关于这个实现过程我们会有这样几个问题：</p><ol><li>是怎样将当前线程添加到等待队列中去的？</li><li>释放锁的过程？</li><li>怎样才能从 await 方法退出？</li></ol><p>而这段代码的逻辑就是告诉我们这三个问题的答案。具体<strong>请看注释</strong>，在第 1 步中调用 addConditionWaiter 将当前线程添加到等待队列中，该方法源码为：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token class-name">Node</span> <span class="token function">addConditionWaiter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token class-name">Node</span> t <span class="token operator">=</span> lastWaiter<span class="token punctuation">;</span>\n    <span class="token comment">// If lastWaiter is cancelled, clean out.</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> t<span class="token punctuation">.</span>waitStatus <span class="token operator">!=</span> <span class="token class-name">Node</span><span class="token punctuation">.</span>CONDITION<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token function">unlinkCancelledWaiters</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        t <span class="token operator">=</span> lastWaiter<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\t<span class="token comment">//将当前线程包装成Node</span>\n    <span class="token class-name">Node</span> node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token punctuation">.</span>CONDITION<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>\n        firstWaiter <span class="token operator">=</span> node<span class="token punctuation">;</span>\n    <span class="token keyword">else</span>\n\t\t<span class="token comment">//尾插入</span>\n        t<span class="token punctuation">.</span>nextWaiter <span class="token operator">=</span> node<span class="token punctuation">;</span>\n\t<span class="token comment">//更新lastWaiter</span>\n    lastWaiter <span class="token operator">=</span> node<span class="token punctuation">;</span>\n    <span class="token keyword">return</span> node<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码就很容易理解了，将当前节点包装成 Node，如果等待队列的 firstWaiter 为 null 的话（等待队列为空队列），则将 firstWaiter 指向当前的 Node,否则，更新 lastWaiter(尾节点)即可。就是<strong>通过尾插入的方式将当前线程封装的 Node 插入到等待队列中即可</strong>，同时可以看出等待队列是一个<strong>不带头结点的链式队列</strong>，之前我们学习 AQS 时知道同步队列<strong>是一个带头结点的链式队列</strong>，这是两者的一个区别。</p><p>将当前节点插入到等待对列之后，会使当前线程释放 lock，由 fullyRelease 方法实现，fullyRelease 源码为：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">fullyRelease</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">boolean</span> failed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n    <span class="token keyword">try</span> <span class="token punctuation">{</span>\n        <span class="token keyword">int</span> savedState <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">release</span><span class="token punctuation">(</span>savedState<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\t\t\t<span class="token comment">//成功释放同步状态</span>\n            failed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n            <span class="token keyword">return</span> savedState<span class="token punctuation">;</span>\n        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n\t\t\t<span class="token comment">//不成功释放同步状态抛出异常</span>\n            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalMonitorStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>failed<span class="token punctuation">)</span>\n            node<span class="token punctuation">.</span>waitStatus <span class="token operator">=</span> <span class="token class-name">Node</span><span class="token punctuation">.</span>CANCELLED<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码就很容易理解了，<strong>调用 AQS 的模板方法 release 方法释放 AQS 的同步状态并且唤醒在同步队列中头结点的后继节点引用的线程</strong>，如果释放成功则正常返回，若失败的话就抛出异常。到目前为止，这两段代码已经解决了前面的两个问题的答案了，还剩下第三个问题，怎样从 await 方法退出？现在回过头再来看 await 方法有这样一段逻辑：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isOnSyncQueue</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\t<span class="token comment">// 3. 当前线程进入到等待状态</span>\n    <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>interruptMode <span class="token operator">=</span> <span class="token function">checkInterruptWhileWaiting</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>\n        <span class="token keyword">break</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>很显然，当线程第一次调用 condition.await()方法时，会进入到这个 while()循环中，然后通过 LockSupport.park(this)方法使得当前线程进入等待状态，那么要想退出这个 await 方法第一个前提条件自然而然的是要先退出这个 while 循环，出口就只剩下两个地方：</p><ol><li>逻辑走到 break 退出 while 循环；</li><li>while 循环中的逻辑判断为 false。</li></ol><p>再看代码出现第 1 种情况的条件是当前等待的线程被中断后代码会走到 break 退出，第二种情况是当前节点被移动到了同步队列中（即另外线程调用的 condition 的 signal 或者 signalAll 方法），while 中逻辑判断为 false 后结束 while 循环。</p><p>总结下，就是<strong>当前线程被中断或者调用 condition.signal/condition.signalAll 方法当前节点移动到了同步队列后</strong> ，这是当前线程退出 await 方法的前提条件。</p><p>当退出 while 循环后就会调用<code>acquireQueued(node, savedState)</code>，该方法的作用是在<strong>自旋过程中线程不断尝试获取同步状态，直至成功（线程获取到 lock）</strong>。这样也说明了<strong>退出 await 方法必须是已经获得了 condition 引用（关联）的 lock</strong>。</p><p>到目前为止，开头的三个问题我们通过阅读源码的方式已经完全找到了答案，也对 await 方法的理解加深。await 方法示意图如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/thinkingme/thinkingme.github.io@master/images/thread/condition-04.png" alt="await方法示意图" loading="lazy"></p><p>如图，调用 condition.await 方法的线程必须是已经获得了 lock，也就是当前线程是同步队列中的头结点。调用该方法后会使得当前线程所封装的 Node 尾插入到等待队列中。</p><blockquote><p>超时机制的支持</p></blockquote><p>condition 还额外支持了超时机制，使用者可调用方法 awaitNanos,awaitUtil。这两个方法的实现原理，基本上与 AQS 中的 tryAcquire 方法如出一辙。</p><blockquote><p>不响应中断的支持</p></blockquote><p>要想不响应中断可以调用 condition.awaitUninterruptibly()方法，该方法的源码为：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code>\t<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">awaitUninterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\t    <span class="token class-name">Node</span> node <span class="token operator">=</span> <span class="token function">addConditionWaiter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\t    <span class="token keyword">int</span> savedState <span class="token operator">=</span> <span class="token function">fullyRelease</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\t    <span class="token keyword">boolean</span> interrupted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n\t    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isOnSyncQueue</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\t        <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\t        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n\t            interrupted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n\t    <span class="token punctuation">}</span>\n\t    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">acquireQueued</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> savedState<span class="token punctuation">)</span> <span class="token operator">||</span> interrupted<span class="token punctuation">)</span>\n\t        <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\t<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段方法与上面的 await 方法基本一致，只不过减少了对中断的处理，并省略了 reportInterruptAfterWait 方法抛被中断的异常。</p><h3 id="signal-signalall-实现原理" tabindex="-1"><a class="header-anchor" href="#signal-signalall-实现原理" aria-hidden="true">#</a> signal/signalAll 实现原理</h3><p><strong>调用 condition 的 signal 或者 signalAll 方法可以将等待队列中等待时间最长的节点移动到同步队列中</strong>，使得该节点能够有机会获得 lock。按照等待队列是先进先出（FIFO）的，所以等待队列的头节点必然会是等待时间最长的节点，也就是每次调用 condition 的 signal 方法是将头节点移动到同步队列中。我们来通过看源码的方式来看这样的猜想是不是对的，signal 方法源码为：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">//1. 先检测当前线程是否已经获取lock</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalMonitorStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token comment">//2. 获取等待队列中第一个节点，之后的操作都是针对这个节点</span>\n\t<span class="token class-name">Node</span> first <span class="token operator">=</span> firstWaiter<span class="token punctuation">;</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>\n        <span class="token function">doSignal</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>signal 方法首先会检测当前线程是否已经获取 lock，如果没有获取 lock 会直接抛出异常，如果获取的话再得到等待队列的头指针引用的节点，之后的操作的 doSignal 方法也是基于该节点。下面我们来看看 doSignal 方法做了些什么事情，doSignal 方法源码为：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code>\t<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doSignal</span><span class="token punctuation">(</span><span class="token class-name">Node</span> first<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\t    <span class="token keyword">do</span> <span class="token punctuation">{</span>\n\t        <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>firstWaiter <span class="token operator">=</span> first<span class="token punctuation">.</span>nextWaiter<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>\n\t            lastWaiter <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n\t\t\t<span class="token comment">//1. 将头结点从等待队列中移除</span>\n\t        first<span class="token punctuation">.</span>nextWaiter <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n\t\t\t<span class="token comment">//2. while中transferForSignal方法对头结点做真正的处理</span>\n\t    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">transferForSignal</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>\n\t             <span class="token punctuation">(</span>first <span class="token operator">=</span> firstWaiter<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\t<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>具体逻辑请看注释，真正对头节点做处理的逻辑在<strong>transferForSignal</strong>放，该方法源码为：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">transferForSignal</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">/*\n     * If cannot change waitStatus, the node has been cancelled.\n     */</span>\n\t<span class="token comment">//1. 更新状态为0</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token punctuation">.</span>CONDITION<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n\n    <span class="token comment">/*\n     * Splice onto queue and try to set waitStatus of predecessor to\n     * indicate that thread is (probably) waiting. If cancelled or\n     * attempt to set waitStatus fails, wake up to resync (in which\n     * case the waitStatus can be transiently and harmlessly wrong).\n     */</span>\n\t<span class="token comment">//2.将该节点移入到同步队列中去</span>\n    <span class="token class-name">Node</span> p <span class="token operator">=</span> <span class="token function">enq</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">int</span> ws <span class="token operator">=</span> p<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> ws<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span><span class="token punctuation">)</span>\n        <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关键逻辑请看注释，这段代码主要做了两件事情 1.将头结点的状态更改为 CONDITION；2.调用 enq 方法，将该节点尾插入到同步队列中，关于 enq 方法请看 AQS 的底层实现这篇文章。现在我们可以得出结论：</p><p><strong>调用 condition 的 signal 的前提条件是当前线程已经获取了 lock，该方法会使得等待队列中的头节点即等待时间最长的那个节点移入到同步队列，而移入到同步队列后才有机会使得等待线程被唤醒，即从 await 方法中的 LockSupport.park(this)方法中返回，从而才有机会使得调用 await 方法的线程成功退出</strong>。signal 执行示意图如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/thinkingme/thinkingme.github.io@master/images/thread/condition-05.png" alt="signal执行示意图" loading="lazy"></p><blockquote><p>signalAll</p></blockquote><p>sigllAll 与 sigal 方法的区别体现在 doSignalAll 方法上，前面我们已经知道 d<strong>oSignal 方法只会对等待队列的头节点进行操作，</strong>，而 doSignalAll 的源码为：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doSignalAll</span><span class="token punctuation">(</span><span class="token class-name">Node</span> first<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    lastWaiter <span class="token operator">=</span> firstWaiter <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n    <span class="token keyword">do</span> <span class="token punctuation">{</span>\n        <span class="token class-name">Node</span> next <span class="token operator">=</span> first<span class="token punctuation">.</span>nextWaiter<span class="token punctuation">;</span>\n        first<span class="token punctuation">.</span>nextWaiter <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n        <span class="token function">transferForSignal</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        first <span class="token operator">=</span> next<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>first <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>该方法只不过时间等待队列中的每一个节点都移入到同步队列中，即“通知”当前调用 condition.await()方法的每一个线程。</p><h2 id="await-与-signal-signalall-的结合思考" tabindex="-1"><a class="header-anchor" href="#await-与-signal-signalall-的结合思考" aria-hidden="true">#</a> await 与 signal/signalAll 的结合思考</h2><p>文章开篇提到等待/通知机制，通过使用 condition 提供的 await 和 signal/signalAll 方法就可以实现这种机制，而这种机制能够解决最经典的问题就是“生产者与消费者问题”，关于“生产者消费者问题”之后会用单独的一篇文章进行讲解，这也是面试的高频考点。await 和 signal 和 signalAll 方法就像一个开关控制着线程 A（等待方）和线程 B（通知方）。它们之间的关系可以用下面一个图来表现得更加贴切：</p><p><img src="https://cdn.jsdelivr.net/gh/thinkingme/thinkingme.github.io@master/images/thread/condition-06.png" alt="condition下的等待通知机制.png" loading="lazy"></p><p>如图，<strong>线程 awaitThread 先通过 lock.lock()方法获取锁成功后调用了 condition.await 方法进入等待队列，而另一个线程 signalThread 通过 lock.lock()方法获取锁成功后调用了 condition.signal 或者 signalAll 方法，使得线程 awaitThread 能够有机会移入到同步队列中，当其他线程释放 lock 后使得线程 awaitThread 能够有机会获取 lock，从而使得线程 awaitThread 能够从 await 方法中退出执行后续操作。如果 awaitThread 获取 lock 失败会直接进入到同步队列</strong>。</p><h2 id="一个例子" tabindex="-1"><a class="header-anchor" href="#一个例子" aria-hidden="true">#</a> 一个例子</h2><p>我们用一个很简单的例子说说 condition 的用法：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AwaitSignal</span> <span class="token punctuation">{</span>\n    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Condition</span> condition <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n\n    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token class-name">Thread</span> waiter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">waiter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        waiter<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token class-name">Thread</span> signaler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">signaler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        signaler<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">static</span> <span class="token keyword">class</span> waiter <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>\n\n        <span class="token annotation punctuation">@Override</span>\n        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword">try</span> <span class="token punctuation">{</span>\n                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;当前条件不满足等待&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                    <span class="token keyword">try</span> <span class="token punctuation">{</span>\n                        condition<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                    <span class="token punctuation">}</span>\n                <span class="token punctuation">}</span>\n                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;接收到通知条件满足&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>\n                lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">static</span> <span class="token keyword">class</span> signaler <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>\n\n        <span class="token annotation punctuation">@Override</span>\n        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword">try</span> <span class="token punctuation">{</span>\n                flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n                condition<span class="token punctuation">.</span><span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>\n                lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果为：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Thread-0当前条件不满足等待\nThread-0接收到通知，条件满足\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>开启了两个线程 waiter 和 signaler，waiter 线程开始执行的时候由于条件不满足，执行 condition.await 方法使该线程进入等待状态同时释放锁，signaler 线程获取到锁之后更改条件，并通知所有的等待线程后释放锁。这时，waiter 线程获取到锁，并由于 signaler 线程更改了条件此时相对于 waiter 来说条件满足，继续执行。</p><hr>',86),p=(0,t._)("p",null,"编辑：沉默王二，内容大部分来源以下三个开源仓库：",-1),o={href:"http://concurrent.redspider.group/",target:"_blank",rel:"noopener noreferrer"},i=(0,t.Uk)("深入浅出 Java 多线程"),c={href:"https://github.com/CL0610/Java-concurrency",target:"_blank",rel:"noopener noreferrer"},l=(0,t.Uk)("并发编程知识总结"),u={href:"https://github.com/CoderLeixiaoshuai/java-eight-part",target:"_blank",rel:"noopener noreferrer"},r=(0,t.Uk)("Java 八股文"),d=(0,t._)("img",{src:"https://cdn.jsdelivr.net/gh/thinkingme/thinkingme.github.io@master/images/xingbiaogongzhonghao.png"},null,-1),k={},v=(0,a(13860).Z)(k,[["render",function(n,s){const a=(0,t.up)("ExternalLinkIcon");return(0,t.wg)(),(0,t.iD)("div",null,[e,(0,t._)("blockquote",null,[p,(0,t._)("ul",null,[(0,t._)("li",null,[(0,t._)("a",o,[i,(0,t.Wm)(a)])]),(0,t._)("li",null,[(0,t._)("a",c,[l,(0,t.Wm)(a)])]),(0,t._)("li",null,[(0,t._)("a",u,[r,(0,t.Wm)(a)])])])]),d])}]])},13860:(n,s)=>{s.Z=(n,s)=>{const a=n.__vccOpts||n;for(const[n,t]of s)a[n]=t;return a}}}]);