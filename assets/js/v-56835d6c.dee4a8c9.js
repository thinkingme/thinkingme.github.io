"use strict";(self.webpackChunkcoding_road=self.webpackChunkcoding_road||[]).push([[6641],{57807:(e,i,t)=>{t.r(i),t.d(i,{data:()=>r});const r={key:"v-56835d6c",path:"/coding-road/java-core/jvm/whereis-the-object.html",title:"Java 创建的对象到底放在哪？",lang:"zh-CN",frontmatter:{category:["Java核心","JVM"],tag:["Java"],summary:"Java 创建的对象到底放在哪？ 大家好，我是二哥呀。创建对象的时候，对象是在堆内存中创建的。但堆内存又分为新生代和老年代，新生代又细分为 Eden 空间、From Survivor 空间、To Survivor 空间。那我们创建的对象到底在哪里？ 一、对象优先在 Eden 分配 堆内存分为新生代和老年代，新生代是用于存放使用后准备被回收的对象，老年代是用于",head:[["meta",{property:"og:url",content:"https://vuepress-theme-hope-v2-demo.mrhope.site/coding-road/java-core/jvm/whereis-the-object.html"}],["meta",{property:"og:site_name",content:"coding-rode"}],["meta",{property:"og:title",content:"Java 创建的对象到底放在哪？"}],["meta",{property:"og:type",content:"article"}],["meta",{property:"og:updated_time",content:"2022-06-04T08:56:49.000Z"}],["meta",{property:"og:locale",content:"zh-CN"}],["meta",{property:"article:tag",content:"Java"}],["meta",{property:"article:modified_time",content:"2022-06-04T08:56:49.000Z"}]]},excerpt:"",headers:[{level:3,title:"一、对象优先在 Eden 分配",slug:"一、对象优先在-eden-分配",children:[]},{level:3,title:"二、大对象直接进入老年代",slug:"二、大对象直接进入老年代",children:[]},{level:3,title:"三、长期存活的对象将进入老年代",slug:"三、长期存活的对象将进入老年代",children:[]},{level:3,title:"四、动态年龄判断",slug:"四、动态年龄判断",children:[]},{level:3,title:"五、空间分配担保",slug:"五、空间分配担保",children:[]}],git:{createdTime:1653617096e3,updatedTime:1654333009e3,contributors:[{name:"林振辉",email:"linzhenhui@apexsoft.com",commits:2},{name:"thinkingme",email:"linzhenhuigg@gmail.com",commits:1}]},readingTime:{minutes:3.42,words:1027},filePathRelative:"coding-road/java-core/jvm/whereis-the-object.md"}},20955:(e,i,t)=>{t.r(i),t.d(i,{default:()=>g});var r=t(95393);const n=(0,r.uE)('<h1 id="java-创建的对象到底放在哪" tabindex="-1"><a class="header-anchor" href="#java-创建的对象到底放在哪" aria-hidden="true">#</a> Java 创建的对象到底放在哪？</h1><p>大家好，我是二哥呀。创建对象的时候，对象是在堆内存中创建的。但堆内存又分为新生代和老年代，新生代又细分为 Eden 空间、From Survivor 空间、To Survivor 空间。<strong>那我们创建的对象到底在哪里</strong>？</p><h3 id="一、对象优先在-eden-分配" tabindex="-1"><a class="header-anchor" href="#一、对象优先在-eden-分配" aria-hidden="true">#</a> 一、对象优先在 Eden 分配</h3><p>堆内存分为新生代和老年代，新生代是用于存放使用后准备被回收的对象，老年代是用于存放生命周期比较长的对象。</p><p>大部分我们创建的对象，都属于生命周期比较短的，所以会存放在新生代。新生代又细分 Eden 空间、From Survivor 空间、To Survivor 空间，我们创建的对象优先在 Eden 分配。</p><p><img src="https://cdn.jsdelivr.net/gh/thinkingme/thinkingme.github.io@master/images/jvm/whereis-the-object-1.png" alt="" loading="lazy"></p><p>随着对象的创建，Eden 剩余内存空间越来越少，就会触发 Minor GC，于是 Eden 的存活对象会放入 From Survivor 空间。</p><p><img src="https://cdn.jsdelivr.net/gh/thinkingme/thinkingme.github.io@master/images/jvm/whereis-the-object-2.png" alt="" loading="lazy"></p><p>Minor GC 后，新对象依然会往 Eden 分配。</p><p><img src="https://cdn.jsdelivr.net/gh/thinkingme/thinkingme.github.io@master/images/jvm/whereis-the-object-3.png" alt="" loading="lazy"></p><p>Eden 剩余内存空间越来越少，又会触发 Minor GC，于是 Eden 和 From Survivor 的存活对象会放入 To Survivor 空间。</p><p><img src="https://cdn.jsdelivr.net/gh/thinkingme/thinkingme.github.io@master/images/jvm/whereis-the-object-4.png" alt="" loading="lazy"></p><h3 id="二、大对象直接进入老年代" tabindex="-1"><a class="header-anchor" href="#二、大对象直接进入老年代" aria-hidden="true">#</a> 二、大对象直接进入老年代</h3><p>在上面的流程中，如果一个对象很大，一直在 Survivor 空间复制来复制去，那很费性能，所以这些大对象直接进入老年代。</p><p>可以用 <code>XX:PretenureSizeThreshold</code> 来设置这些大对象的阈值。</p><p><img src="https://cdn.jsdelivr.net/gh/thinkingme/thinkingme.github.io@master/images/jvm/whereis-the-object-5.png" alt="" loading="lazy"></p><h3 id="三、长期存活的对象将进入老年代" tabindex="-1"><a class="header-anchor" href="#三、长期存活的对象将进入老年代" aria-hidden="true">#</a> 三、长期存活的对象将进入老年代</h3><p>在上面的流程中，如果一个对象 Hello_A，已经经历了 15 次 Minor GC 还存活在 Survivor 空间中，那他即将转移到老年代。这个 15 可以通过 <code>-XX:MaxTenuringThreshold</code> 来设置的，默认是 15。</p><p>虚拟机为了给对象计算他到底经历了几次 Minor GC，会给每个对象定义了一个对象年龄计数器。如果对象在 Eden 中经过第一次 Minor GC 后仍然存活，移动到 Survivor 空间年龄加 1，在 Survivor 区中每经历过 Minor GC 后仍然存活年龄再加 1。年龄到了 15，就到了老年代。</p><p><img src="https://cdn.jsdelivr.net/gh/thinkingme/thinkingme.github.io@master/images/jvm/whereis-the-object-6.png" alt="" loading="lazy"></p><h3 id="四、动态年龄判断" tabindex="-1"><a class="header-anchor" href="#四、动态年龄判断" aria-hidden="true">#</a> 四、动态年龄判断</h3><p>除了年龄达到 MaxTenuringThreshold 的值，还有另外一个方式进入老年代，那就是动态年龄判断：在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。</p><p>比如 Survivor 是 100M，Hello1 和 Hello2 都是 3 岁，且总和超过了 50M，Hello3 是 4 岁，这个时候，这三个对象都将到老年代。</p><p><img src="https://cdn.jsdelivr.net/gh/thinkingme/thinkingme.github.io@master/images/jvm/whereis-the-object-7.png" alt="" loading="lazy"></p><h3 id="五、空间分配担保" tabindex="-1"><a class="header-anchor" href="#五、空间分配担保" aria-hidden="true">#</a> 五、空间分配担保</h3><p>上面的流程提过，存活的对象都会放入另外一个 Survivor 空间，如果这些存活的对象比 Survivor 空间还大呢？整个流程如下：</p><ul><li>Minor GC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果大于，则发起 Minor GC。</li><li>如果小于，则看 HandlePromotionFailure 有没有设置，如果没有设置，就发起 full gc。</li><li>如果设置了 HandlePromotionFailure，则看老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果小于，就发起 full gc。</li><li>如果大于，发起 Minor GC。Minor GC 后，看 Survivor 空间是否足够存放存活对象，如果不够，就放入老年代，如果够放，就直接存放 Survivor 空间。如果老年代都不够放存活对象，担保失败（Handle Promotion Failure），发起 full gc。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/thinkingme/thinkingme.github.io@master/images/jvm/whereis-the-object-8.png" alt="" loading="lazy"></p><p>好了，今天就分享到这儿吧，我是二哥呀，我们下期见~~</p><hr>',30),a=(0,r.Uk)("原文链接："),o={href:"http://juejin.cn/post/7052894117105238053",target:"_blank",rel:"noopener noreferrer"},h=(0,r.Uk)("juejin.cn/post/7052894117105238053"),l=(0,r._)("p",null,[(0,r._)("img",{src:"https://cdn.jsdelivr.net/gh/thinkingme/thinkingme.github.io@master/images/xingbiaogongzhonghao.png",alt:"",loading:"lazy"})],-1),d={},g=(0,t(13860).Z)(d,[["render",function(e,i){const t=(0,r.up)("ExternalLinkIcon");return(0,r.wg)(),(0,r.iD)("div",null,[n,(0,r._)("blockquote",null,[(0,r._)("p",null,[a,(0,r._)("a",o,[h,(0,r.Wm)(t)])])]),l])}]])},13860:(e,i)=>{i.Z=(e,i)=>{const t=e.__vccOpts||e;for(const[e,r]of i)t[e]=r;return t}}}]);