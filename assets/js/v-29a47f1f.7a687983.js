"use strict";(self.webpackChunkcoding_road=self.webpackChunkcoding_road||[]).push([[4437],{63413:(e,a,t)=>{t.r(a),t.d(a,{data:()=>s});const s={key:"v-29a47f1f",path:"/coding-road/java-core/basic-extra-meal/class-object.html",title:"先有 Class 还是先有 Object？",lang:"zh-CN",frontmatter:{category:["Java核心"],tag:["Java"],summary:"先有 Class 还是先有 Object？ Java 对象模型中： 所有的类都是 Class 类的实例，Object 是类，那么 Object 也是 Class 类的一个实例。; 所有的类都最终继承自 Object 类，Class 是类，那么 Class 也继承自 Object。; 那到底是先有 Class 还是先有 Object？ JVM 是怎么处理这个“",head:[["meta",{property:"og:url",content:"https://vuepress-theme-hope-v2-demo.mrhope.site/coding-road/java-core/basic-extra-meal/class-object.html"}],["meta",{property:"og:site_name",content:"coding-rode"}],["meta",{property:"og:title",content:"先有 Class 还是先有 Object？"}],["meta",{property:"og:type",content:"article"}],["meta",{property:"og:updated_time",content:"2022-06-04T08:56:49.000Z"}],["meta",{property:"og:locale",content:"zh-CN"}],["meta",{property:"article:tag",content:"Java"}],["meta",{property:"article:modified_time",content:"2022-06-04T08:56:49.000Z"}]]},excerpt:"",headers:[],git:{createdTime:1653617096e3,updatedTime:1654333009e3,contributors:[{name:"林振辉",email:"linzhenhui@apexsoft.com",commits:2},{name:"thinkingme",email:"linzhenhuigg@gmail.com",commits:1}]},readingTime:{minutes:4.59,words:1376},filePathRelative:"coding-road/java-core/basic-extra-meal/class-object.md"}},81880:(e,a,t)=>{t.r(a),t.d(a,{default:()=>u});var s=t(95393);const n=(0,s._)("h1",{id:"先有-class-还是先有-object",tabindex:"-1"},[(0,s._)("a",{class:"header-anchor",href:"#先有-class-还是先有-object","aria-hidden":"true"},"#"),(0,s.Uk)(" 先有 Class 还是先有 Object？")],-1),i=(0,s._)("p",null,"Java 对象模型中：",-1),l=(0,s._)("ul",null,[(0,s._)("li",null,"所有的类都是 Class 类的实例，Object 是类，那么 Object 也是 Class 类的一个实例。"),(0,s._)("li",null,"所有的类都最终继承自 Object 类，Class 是类，那么 Class 也继承自 Object。")],-1),r=(0,s._)("p",null,"那到底是先有 Class 还是先有 Object？ JVM 是怎么处理这个“鸡·蛋”问题呢？",-1),o=(0,s._)("p",null,[(0,s._)("img",{src:"https://cdn.jsdelivr.net/gh/thinkingme/thinkingme.github.io@master/images/basic-extra-meal/class-object-2f47490c-70b8-41b8-9551-42c2f98eea91.png",alt:"",loading:"lazy"})],-1),c=(0,s._)("p",null,"针对这个问题，我在知乎上看到了 R 大的一个回答，正好解答了我心中的疑惑，就分享出来给各位小伙伴一个参考和启发~",-1),d=(0,s.Uk)("作者：RednaxelaFX，整理：沉默王二，参考链接："),p={href:"https://www.zhihu.com/question/30301819/answer/47539163",target:"_blank",rel:"noopener noreferrer"},v=(0,s.Uk)("https://www.zhihu.com/question/30301819/answer/47539163"),m=(0,s.uE)('<hr><p>“鸡・蛋”问题通常都是通过一种叫“自举”（bootstrap）的过程来解决的。</p><p>“鸡蛋问题”的根本矛盾就在于假定了“鸡”或“蛋”的其中一个要先进入“完全可用”的状态。而许多现实中被简化为“鸡蛋问题”的情况实际可以在“混沌”中把“鸡”和“蛋”都初始化好，而不存在先后问题；在它们初始化的过程中，两者都不处于“完全可用”状态，而完成初始化后它们就同时都进入了可用状态。</p><p>打个比方，番茄炒蛋。并不是要先把番茄完全炒好，然后把鸡蛋完全炒好，然后把它们混起来；而是先炒番茄炒到半熟，再炒鸡蛋炒到半熟，然后把两个半熟的部分混在一起同时炒熟。</p><p>对于<strong>先有 Class 还是先有 Object</strong>这个问题来说，题主假设所有的类都是 Class 类的实例，Object 是类，那么 Object 也是 Class 类的一个实例，这个假设就是错的。</p><p><code>java.lang.Object</code>是一个 Java 类，但并不是<code>java.lang.Class</code>的一个实例。后者只是一个用于描述 Java 类与接口的、用于支持反射操作的类型。这点上 Java 跟其它一些更纯粹的面向对象语言（例如 Python 和 Ruby）不同。</p><p>第二个假设“所有的类都最终继承自 Object 类，Class 是类，那么 Class 也继承自 Object”是对的，<code>java.lang.Class</code>是<code>java.lang.Object</code>的派生类，前者继承自后者。</p><p>虽然第 1 个假设不对，但“鸡蛋问题”仍然存在：在一个已经启动完毕、可以使用的 Java 对象系统里，必须要有一个<code>java.lang.Class</code>实例对应<code>java.lang.Object</code>这个类；而<code>java.lang.Class</code>是<code>java.lang.Object</code>的派生类，按“一般思维”，前者应该要在后者完成初始化之后才可以初始化…</p><p>事实是：这些相互依赖的核心类型完全可以在“混沌”中一口气都初始化好，然后对象系统的状态才叫做完成了“bootstrap”，后面就可以按照 Java 对象系统的一般规则去运行。JVM、JavaScript、Python、Ruby 等的运行时都有这样的 bootstrap 过程。</p><p>在“混沌”（boostrap 过程）里，JVM 可以为对象系统中最重要的一些核心类型先分配好内存空间，让它们进入[已分配空间]但[尚未完全初始化]状态。</p><p>此时这些对象虽然已经分配了空间，但因为状态还不完整所以尚不可使用。然后，通过这些分配好的空间把这些核心类型之间的引用关系串好。</p><p>到此为止所有动作都由 JVM 完成，尚未执行任何 Java 字节码。然后这些核心类型就进入了[完全初始化]状态，对象系统就可以开始自我运行下去，也就是可以开始执行 Java 字节码来进一步完成 Java 系统的初始化了。</p><p>在 HotSpot VM 里，有一个叫做“Universe”的 C++类用于记录对象系统的总体状态。它有这么两个有趣的字段记录当前是处于 bootstrapping 阶段还是已经完全初始化好：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>static bool is_bootstrapping()                      { return _bootstrapping; }\nstatic bool is_fully_initialized()                  { return _fully_initialized; }\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>然后<code>Universe::genesis()</code>函数会在 bootstrap 阶段中创建核心类型的对象模型，其中会调用<code>SystemDictionary::initialize()</code>来初始化对象系统的核心类型，其中会进一步跑到<code>SystemDictionary::initialize_preloaded_classes()</code>来创建<code>java.lang.Object</code>、<code>java.lang.Class</code>等核心类型。</p><p>这个函数在加载了<code>java.lang.Object</code>、<code>java.lang.Class</code>等核心类型后会调用<code>Universe::fixup_mirrors()</code>来完成前面说的“把引用关系串起来”的动作：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// Fixup mirrors for classes loaded before java.lang.Class.\n// These calls iterate over the objects currently in the perm gen\n// so calling them at this point is matters (not before when there\n// are fewer objects and not later after there are more objects\n// in the perm gen.\nUniverse::initialize_basic_type_mirrors(CHECK);\nUniverse::fixup_mirrors(CHECK);\n\nvoid Universe::fixup_mirrors(TRAPS) {\n  // Bootstrap problem: all classes gets a mirror (java.lang.Class instance) assigned eagerly,\n  // but we cannot do that for classes created before java.lang.Class is loaded. Here we simply\n  // walk over permanent objects created so far (mostly classes) and fixup their mirrors. Note\n  // that the number of objects allocated at this point is very small.\n\n  // ...\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>就是这样：“<strong>Object 里有一个成员变量指向 Class 类实例 c，c 保存这个 Object 成员、方法的名字和地址的 Map 映射用作反射</strong>。”涉及到主类有这么几个：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/ade5be2b1758/src/share/vm/memory/universe.hpp#l399\nhttp://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/ade5be2b1758/src/share/vm/memory/universe.cpp#l259\nhttp://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/ade5be2b1758/src/share/vm/classfile/systemDictionary.cpp#l1814\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>分享的最后，二哥要简单说两句，每次看 R 大的内容，总是感觉膝盖忍不住要跪一下，只能说写过 JVM 的男人就是不一样。喜欢研究 CPP 源码的话小伙伴可以再深入学习下，一定会有所收获。</p><p><img src="https://cdn.jsdelivr.net/gh/thinkingme/thinkingme.github.io@master/images/xingbiaogongzhonghao.png" alt="" loading="lazy"></p>',21),b={},u=(0,t(13860).Z)(b,[["render",function(e,a){const t=(0,s.up)("ExternalLinkIcon");return(0,s.wg)(),(0,s.iD)("div",null,[n,i,l,r,o,c,(0,s._)("blockquote",null,[(0,s._)("p",null,[d,(0,s._)("a",p,[v,(0,s.Wm)(t)])])]),m])}]])},13860:(e,a)=>{a.Z=(e,a)=>{const t=e.__vccOpts||e;for(const[e,s]of a)t[e]=s;return t}}}]);