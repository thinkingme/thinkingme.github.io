"use strict";(self.webpackChunkcoding_road=self.webpackChunkcoding_road||[]).push([[2667],{41703:(n,s,a)=>{a.r(s),a.d(s,{data:()=>e});const e={key:"v-51313057",path:"/coding-road/javaee/spring/spring-framework-code.html",title:"spring框架代码原理",lang:"zh-CN",frontmatter:{summary:'spring框架代码原理 " 本文研究通过迷你spring配合官方源码理解，源码链接：GitHub - DerekYRC/mini-spring: mini-spring是简化版的spring框架，能帮助你快速熟悉spring源码和掌握spring的核心原理。抽取了spring的核心逻辑，代码极度简化，保留spring的核心功能，如IoC和AOP、资源加载器',head:[["meta",{property:"og:url",content:"https://vuepress-theme-hope-v2-demo.mrhope.site/coding-road/javaee/spring/spring-framework-code.html"}],["meta",{property:"og:site_name",content:"coding-rode"}],["meta",{property:"og:title",content:"spring框架代码原理"}],["meta",{property:"og:type",content:"article"}],["meta",{property:"og:updated_time",content:"2023-01-31T07:03:45.000Z"}],["meta",{property:"og:locale",content:"zh-CN"}],["meta",{property:"article:modified_time",content:"2023-01-31T07:03:45.000Z"}]]},excerpt:"",headers:[{level:2,title:"springbean生命周期",slug:"springbean生命周期",children:[]},{level:2,title:"synchronized加锁",slug:"synchronized加锁",children:[]},{level:2,title:"prepare",slug:"prepare",children:[{level:3,title:"preoareRefresh",slug:"preoarerefresh",children:[]},{level:3,title:"prepareBeanFactory",slug:"preparebeanfactory",children:[]}]},{level:2,title:"循环依赖",slug:"循环依赖",children:[]}],git:{createdTime:1675148625e3,updatedTime:1675148625e3,contributors:[{name:"thinkingme",email:"linzhenhuigg@gmail.com",commits:1}]},readingTime:{minutes:2.71,words:813},filePathRelative:"coding-road/javaee/spring/spring-framework-code.md"}},23429:(n,s,a)=>{a.r(s),a.d(s,{default:()=>r});var e=a(95393);const t=(0,e._)("h1",{id:"spring框架代码原理",tabindex:"-1"},[(0,e._)("a",{class:"header-anchor",href:"#spring框架代码原理","aria-hidden":"true"},"#"),(0,e.Uk)(" spring框架代码原理")],-1),i=(0,e.Uk)("本文研究通过迷你spring配合官方源码理解，源码链接："),p={href:"https://github.com/DerekYRC/mini-spring/",target:"_blank",rel:"noopener noreferrer"},o=(0,e.Uk)("GitHub - DerekYRC/mini-spring: mini-spring是简化版的spring框架，能帮助你快速熟悉spring源码和掌握spring的核心原理。抽取了spring的核心逻辑，代码极度简化，保留spring的核心功能，如IoC和AOP、资源加载器、事件监听器、类型转换、容器扩展点、bean生命周期和作用域、应用上下文等核心功能。"),c=(0,e.uE)('<h2 id="springbean生命周期" tabindex="-1"><a class="header-anchor" href="#springbean生命周期" aria-hidden="true">#</a> springbean生命周期</h2><p>可以看看org.springframework.beans.factory.BeanFactory类的注释</p><p>Bean factory implementations should support the standard bean lifecycle interfaces as far as possible. The full set of initialization methods and their standard order is:</p><ol><li><p>BeanNameAware&#39;s setBeanName</p></li><li><p>BeanClassLoaderAware&#39;s setBeanClassLoader</p></li><li><p>BeanFactoryAware&#39;s setBeanFactory</p></li><li><p>EnvironmentAware&#39;s setEnvironment</p></li><li><p>EmbeddedValueResolverAware&#39;s setEmbeddedValueResolver</p></li><li><p>ResourceLoaderAware&#39;s setResourceLoader (only applicable when running in an application context)</p></li><li><p>ApplicationEventPublisherAware&#39;s setApplicationEventPublisher (only applicable when running in an application context)</p></li><li><p>MessageSourceAware&#39;s setMessageSource (only applicable when running in an application context)</p></li><li><p>ApplicationContextAware&#39;s setApplicationContext (only applicable when running in an application context)</p></li><li><p>ServletContextAware&#39;s setServletContext (only applicable when running in a web application context)</p></li><li><p>postProcessBeforeInitialization methods of BeanPostProcessors InitializingBean&#39;s afterPropertiesSet</p></li><li><p>a custom init-method definition</p></li><li><p>postProcessAfterInitialization methods of BeanPostProcessors</p></li></ol><p>On shutdown of a bean factory, the following lifecycle methods apply:</p><ol><li><p>postProcessBeforeDestruction methods of DestructionAwareBeanPostProcessors</p></li><li><p>DisposableBean&#39;s destroy</p></li><li><p>a custom destroy-method definition</p></li></ol><blockquote><p>总结就是</p></blockquote><p>创建时：</p><ol><li><p>各种xxxAware接口实现后会进行注入对应的内容</p></li><li><p>bean后置处理器类的postProcessBeforeInitialization实现方法执行</p></li><li></li><li><p>init-method</p></li><li><p>bean后置处理器类的postProcessAfterInitialization实现方法执行</p></li></ol><p>销毁时：</p><ol><li><p>DestructionAwareBeanPostProcessors的postProcessBeforeDestruction执行</p></li><li><p>bean销毁</p></li><li><p>destroy-method</p></li></ol><p>然后我们看看具体的实现</p><p>直接上重点，org.springframework.context.support.AbstractApplicationContext类下面的refresh()方法，用于刷新spring容器上下文。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span><span class="token punctuation">,</span> <span class="token class-name">IllegalStateException</span> <span class="token punctuation">{</span>\n        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>startupShutdownMonitor<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token comment">// Prepare this context for refreshing.</span>\n            <span class="token function">prepareRefresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n            <span class="token comment">// Tell the subclass to refresh the internal bean factory.</span>\n            <span class="token class-name">ConfigurableListableBeanFactory</span> beanFactory <span class="token operator">=</span> <span class="token function">obtainFreshBeanFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n            <span class="token comment">// Prepare the bean factory for use in this context.</span>\n            <span class="token function">prepareBeanFactory</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n            <span class="token keyword">try</span> <span class="token punctuation">{</span>\n                <span class="token comment">// Allows post-processing of the bean factory in context subclasses.</span>\n                <span class="token function">postProcessBeanFactory</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n                <span class="token comment">// Invoke factory processors registered as beans in the context.</span>\n                <span class="token function">invokeBeanFactoryPostProcessors</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n                <span class="token comment">// Register bean processors that intercept bean creation.</span>\n                <span class="token function">registerBeanPostProcessors</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n                <span class="token comment">// Initialize message source for this context.</span>\n                <span class="token function">initMessageSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n                <span class="token comment">// Initialize event multicaster for this context.</span>\n                <span class="token function">initApplicationEventMulticaster</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n                <span class="token comment">// Initialize other special beans in specific context subclasses.</span>\n                <span class="token function">onRefresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n                <span class="token comment">// Check for listener beans and register them.</span>\n                <span class="token function">registerListeners</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n                <span class="token comment">// Instantiate all remaining (non-lazy-init) singletons.</span>\n                <span class="token function">finishBeanFactoryInitialization</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n                <span class="token comment">// Last step: publish corresponding event.</span>\n                <span class="token function">finishRefresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n\n            <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">BeansException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                <span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isWarnEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                    logger<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">&quot;Exception encountered during context initialization - &quot;</span> <span class="token operator">+</span>\n                            <span class="token string">&quot;cancelling refresh attempt: &quot;</span> <span class="token operator">+</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token punctuation">}</span>\n\n                <span class="token comment">// Destroy already created singletons to avoid dangling resources.</span>\n                <span class="token function">destroyBeans</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n                <span class="token comment">// Reset &#39;active&#39; flag.</span>\n                <span class="token function">cancelRefresh</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n                <span class="token comment">// Propagate exception to caller.</span>\n                <span class="token keyword">throw</span> ex<span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n\n            <span class="token keyword">finally</span> <span class="token punctuation">{</span>\n                <span class="token comment">// Reset common introspection caches in Spring&#39;s core, since we</span>\n                <span class="token comment">// might not ever need metadata for singleton beans anymore...</span>\n                <span class="token function">resetCommonCaches</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我来根据每个方法逐一分析一下。</p><h2 id="synchronized加锁" tabindex="-1"><a class="header-anchor" href="#synchronized加锁" aria-hidden="true">#</a> synchronized加锁</h2><p>我们可以在spring ioc容器加入bean时看到spring做了一些加锁的处理</p><p>org.springframework.beans.factory.support.DefaultSingletonBeanRegistry</p><p>一开始想到，spring初始化bean是单线程的，为什么还需要加锁呢。</p><p>后来认为，spring中controller等类是会有多线程操作的，而如果我们设置bean为lazy也就是懒加载。那么在这些多线程操作的类中如果进行加载bean的操作的话，有可能会引发多线程的问题。</p><h2 id="prepare" tabindex="-1"><a class="header-anchor" href="#prepare" aria-hidden="true">#</a> prepare</h2><p>准备阶段</p><h3 id="preoarerefresh" tabindex="-1"><a class="header-anchor" href="#preoarerefresh" aria-hidden="true">#</a> preoareRefresh</h3><p>ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</p><h3 id="preparebeanfactory" tabindex="-1"><a class="header-anchor" href="#preparebeanfactory" aria-hidden="true">#</a> prepareBeanFactory</h3><h2 id="循环依赖" tabindex="-1"><a class="header-anchor" href="#循环依赖" aria-hidden="true">#</a> 循环依赖</h2><p>spring解决循环依赖，正常来说二级缓存就可以解决循环依赖问题，但是spring还需要存放代理对象，所以需要三级缓存，其中一个来存放代理过的对象。</p><p>我感觉二级缓存就够了，三级缓存只是个写法吧</p>',28),l={},r=(0,a(13860).Z)(l,[["render",function(n,s){const a=(0,e.up)("ExternalLinkIcon");return(0,e.wg)(),(0,e.iD)("div",null,[t,(0,e._)("blockquote",null,[(0,e._)("p",null,[i,(0,e._)("a",p,[o,(0,e.Wm)(a)])])]),c])}]])},13860:(n,s)=>{s.Z=(n,s)=>{const a=n.__vccOpts||n;for(const[n,e]of s)a[n]=e;return a}}}]);