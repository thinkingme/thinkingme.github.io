"use strict";(self.webpackChunkcoding_road=self.webpackChunkcoding_road||[]).push([[7632],{63033:(n,s,a)=>{a.r(s),a.d(s,{data:()=>e});const e={key:"v-134179f1",path:"/coding-road/java-core/juc/ReentrantReadWriteLock.html",title:"深入理解 Java 并发读写锁 ReentrantReadWriteLock",lang:"zh-CN",frontmatter:{category:["Java核心","并发编程"],tag:["Java"],summary:"深入理解 Java 并发读写锁 ReentrantReadWriteLock 在并发场景中用于解决线程安全的问题，我们几乎会高频率的使用到独占式锁，通常使用 java 提供的关键字 synchronized 或者 concurrents 包中实现了 Lock 接口的 ReentrantLock。它们都是独占式获取锁，也就是在同一时刻只有一个线程能够获取锁。 ",head:[["meta",{property:"og:url",content:"https://vuepress-theme-hope-v2-demo.mrhope.site/coding-road/java-core/juc/ReentrantReadWriteLock.html"}],["meta",{property:"og:site_name",content:"coding-rode"}],["meta",{property:"og:title",content:"深入理解 Java 并发读写锁 ReentrantReadWriteLock"}],["meta",{property:"og:type",content:"article"}],["meta",{property:"og:updated_time",content:"2022-06-04T08:56:49.000Z"}],["meta",{property:"og:locale",content:"zh-CN"}],["meta",{property:"article:tag",content:"Java"}],["meta",{property:"article:modified_time",content:"2022-06-04T08:56:49.000Z"}]]},excerpt:"",headers:[{level:2,title:"写锁详解",slug:"写锁详解",children:[{level:3,title:"写锁的获取",slug:"写锁的获取",children:[]},{level:3,title:"写锁的释放",slug:"写锁的释放",children:[]}]},{level:2,title:"读锁详解",slug:"读锁详解",children:[{level:3,title:"读锁的获取",slug:"读锁的获取",children:[]},{level:3,title:"读锁的释放",slug:"读锁的释放",children:[]}]},{level:2,title:"锁降级",slug:"锁降级",children:[]}],git:{createdTime:1653617096e3,updatedTime:1654333009e3,contributors:[{name:"林振辉",email:"linzhenhui@apexsoft.com",commits:2},{name:"thinkingme",email:"linzhenhuigg@gmail.com",commits:1}]},readingTime:{minutes:7.79,words:2337},filePathRelative:"coding-road/java-core/juc/ReentrantReadWriteLock.md"}},99054:(n,s,a)=>{a.r(s),a.d(s,{default:()=>v});var e=a(95393);const t=(0,e.uE)('<h1 id="深入理解-java-并发读写锁-reentrantreadwritelock" tabindex="-1"><a class="header-anchor" href="#深入理解-java-并发读写锁-reentrantreadwritelock" aria-hidden="true">#</a> 深入理解 Java 并发读写锁 ReentrantReadWriteLock</h1><p>在并发场景中用于解决线程安全的问题，我们几乎会高频率的使用到独占式锁，通常使用 java 提供的关键字 synchronized 或者 concurrents 包中实现了 Lock 接口的 ReentrantLock。它们都是独占式获取锁，也就是在同一时刻只有一个线程能够获取锁。</p><p>而在一些业务场景中，大部分只是读数据，写数据很少，如果仅仅是读数据的话并不会影响数据正确性（出现脏读），而如果在这种业务场景下，依然使用独占锁的话，很显然这将是出现性能瓶颈的地方。针对这种读多写少的情况，java 还提供了另外一个实现 Lock 接口的 ReentrantReadWriteLock(读写锁)。</p><p><strong>读写锁允许同一时刻被多个读线程访问，但是在写线程访问时，所有的读线程和其他的写线程都会被阻塞</strong>。在分析 WirteLock 和 ReadLock 的互斥性时可以按照 WriteLock 与 WriteLock 之间，WriteLock 与 ReadLock 之间以及 ReadLock 与 ReadLock 之间进行分析。</p><p>更多关于读写锁特性介绍大家可以看源码上的介绍（阅读源码时最好的一种学习方式，我也正在学习中，与大家共勉），这里做一个归纳总结：</p><ol><li><strong>公平性选择</strong>：支持非公平性（默认）和公平的锁获取方式，吞吐量还是非公平优于公平；</li><li><strong>重入性</strong>：支持重入，读锁获取后能再次获取，写锁获取之后能够再次获取写锁，同时也能够获取读锁；</li><li><strong>锁降级</strong>：遵循获取写锁，获取读锁再释放写锁的次序，写锁能够降级成为读锁</li></ol><p>要想能够彻底的理解读写锁必须能够理解这样几个问题：</p><ul><li><ol><li>读写锁是怎样实现分别记录读写状态的？</li></ol></li><li><ol start="2"><li>写锁是怎样获取和释放的？</li></ol></li><li>3.读锁是怎样获取和释放的？</li></ul><p>我们带着这样的三个问题，再去了解下读写锁。</p><h2 id="写锁详解" tabindex="-1"><a class="header-anchor" href="#写锁详解" aria-hidden="true">#</a> 写锁详解</h2><h3 id="写锁的获取" tabindex="-1"><a class="header-anchor" href="#写锁的获取" aria-hidden="true">#</a> 写锁的获取</h3><p>同步组件的实现聚合了同步器（AQS），并通过重写重写同步器（AQS）中的方法实现同步组件的同步语义。因此，写锁的实现依然也是采用这种方式。在同一时刻写锁是不能被多个线程所获取，很显然写锁是独占式锁，而实现写锁的同步语义是通过重写 AQS 中的 tryAcquire 方法实现的。源码为:</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">/*\n     * Walkthrough:\n     * 1. If read count nonzero or write count nonzero\n     *    and owner is a different thread, fail.\n     * 2. If count would saturate, fail. (This can only\n     *    happen if count is already nonzero.)\n     * 3. Otherwise, this thread is eligible for lock if\n     *    it is either a reentrant acquire or\n     *    queue policy allows it. If so, update state\n     *    and set owner.\n     */</span>\n    <span class="token class-name">Thread</span> current <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\t<span class="token comment">// 1. 获取写锁当前的同步状态</span>\n    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\t<span class="token comment">// 2. 获取写锁获取的次数</span>\n    <span class="token keyword">int</span> w <span class="token operator">=</span> <span class="token function">exclusiveCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span>\n\t\t<span class="token comment">// 3.1 当读锁已被读线程获取或者当前线程不是已经获取写锁的线程的话</span>\n\t\t<span class="token comment">// 当前线程获取写锁失败</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>w <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> current <span class="token operator">!=</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>w <span class="token operator">+</span> <span class="token function">exclusiveCount</span><span class="token punctuation">(</span>acquires<span class="token punctuation">)</span> <span class="token operator">&gt;</span> MAX_COUNT<span class="token punctuation">)</span>\n            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&quot;Maximum lock count exceeded&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token comment">// Reentrant acquire</span>\n\t\t<span class="token comment">// 3.2 当前线程获取写锁，支持可重复加锁</span>\n        <span class="token function">setState</span><span class="token punctuation">(</span>c <span class="token operator">+</span> acquires<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\t<span class="token comment">// 3.3 写锁未被任何线程获取，当前线程可获取写锁</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">writerShouldBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span>\n        <span class="token operator">!</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> c <span class="token operator">+</span> acquires<span class="token punctuation">)</span><span class="token punctuation">)</span>\n        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n    <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码的逻辑请看注释，这里有一个地方需要重点关注，exclusiveCount(c)方法，该方法源码为： <code>static int exclusiveCount(int c) { return c &amp; EXCLUSIVE_MASK; }</code></p><p>其中<strong>EXCLUSIVE_MASK</strong>为: <code>static final int EXCLUSIVE_MASK = (1 &lt;&lt; SHARED_SHIFT) - 1;</code> EXCLUSIVE_MASK 为 1 左移 16 位然后减 1，即为 0x0000FFFF。而 exclusiveCount 方法是将同步状态（state 为 int 类型）与 0x0000FFFF 相与，即取同步状态的低 16 位。那么低 16 位代表什么呢？根据 exclusiveCount 方法的注释为独占式获取的次数即写锁被获取的次数，现在就可以得出来一个结论<strong>同步状态的低 16 位用来表示写锁的获取次数</strong>。同时还有一个方法值得我们注意：</p><p><code>static int sharedCount(int c) { return c &gt;&gt;&gt; SHARED_SHIFT; }</code></p><p>该方法是获取读锁被获取的次数，是将同步状态（int c）右移 16 次，即取同步状态的高 16 位，现在我们可以得出另外一个结论<strong>同步状态的高 16 位用来表示读锁被获取的次数</strong>。现在还记得我们开篇说的需要弄懂的第一个问题吗？读写锁是怎样实现分别记录读锁和写锁的状态的，现在这个问题的答案就已经被我们弄清楚了，其示意图如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/thinkingme/thinkingme.github.io@master/images/thread/ReentrantReadWriteLock-f714bdd6-917a-4d25-ac11-7e85b0ec1b14.png" alt="读写锁的读写状态设计" loading="lazy"></p><p>现在我们回过头来看写锁获取方法 tryAcquire，其主要逻辑为：<strong>当读锁已经被读线程获取或者写锁已经被其他写线程获取，则写锁获取失败；否则，获取成功并支持重入，增加写状态。</strong></p><h3 id="写锁的释放" tabindex="-1"><a class="header-anchor" href="#写锁的释放" aria-hidden="true">#</a> 写锁的释放</h3><p>写锁释放通过重写 AQS 的 tryRelease 方法，源码为：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span> releases<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalMonitorStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\t<span class="token comment">//1. 同步状态减去写状态</span>\n    <span class="token keyword">int</span> nextc <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> releases<span class="token punctuation">;</span>\n\t<span class="token comment">//2. 当前写状态是否为0，为0则释放写锁</span>\n    <span class="token keyword">boolean</span> free <span class="token operator">=</span> <span class="token function">exclusiveCount</span><span class="token punctuation">(</span>nextc<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>free<span class="token punctuation">)</span>\n        <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\t<span class="token comment">//3. 不为0则更新同步状态</span>\n    <span class="token function">setState</span><span class="token punctuation">(</span>nextc<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">return</span> free<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>源码的实现逻辑请看注释，不难理解与 ReentrantLock 基本一致，这里需要注意的是，减少写状态<code> int nextc = getState() - releases;</code>只需要用<strong>当前同步状态直接减去写状态的原因正是我们刚才所说的写状态是由同步状态的低 16 位表示的</strong>。</p><h2 id="读锁详解" tabindex="-1"><a class="header-anchor" href="#读锁详解" aria-hidden="true">#</a> 读锁详解</h2><h3 id="读锁的获取" tabindex="-1"><a class="header-anchor" href="#读锁的获取" aria-hidden="true">#</a> 读锁的获取</h3><p>看完了写锁，现在来看看读锁，读锁不是独占式锁，即同一时刻该锁可以被多个读线程获取也就是一种共享式锁。按照之前对 AQS 介绍，实现共享式同步组件的同步语义需要通过重写 AQS 的 tryAcquireShared 方法和 tryReleaseShared 方法。读锁的获取实现方法为：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">tryAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> unused<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">/*\n     * Walkthrough:\n     * 1. If write lock held by another thread, fail.\n     * 2. Otherwise, this thread is eligible for\n     *    lock wrt state, so ask if it should block\n     *    because of queue policy. If not, try\n     *    to grant by CASing state and updating count.\n     *    Note that step does not check for reentrant\n     *    acquires, which is postponed to full version\n     *    to avoid having to check hold count in\n     *    the more typical non-reentrant case.\n     * 3. If step 2 fails either because thread\n     *    apparently not eligible or CAS fails or count\n     *    saturated, chain to version with full retry loop.\n     */</span>\n    <span class="token class-name">Thread</span> current <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\t<span class="token comment">//1. 如果写锁已经被获取并且获取写锁的线程不是当前线程的话，当前</span>\n\t<span class="token comment">// 线程获取读锁失败返回-1</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">exclusiveCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>\n        <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> current<span class="token punctuation">)</span>\n        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>\n    <span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token function">sharedCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">readerShouldBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>\n        r <span class="token operator">&lt;</span> MAX_COUNT <span class="token operator">&amp;&amp;</span>\n\t\t<span class="token comment">//2. 当前线程获取读锁</span>\n        <span class="token function">compareAndSetState</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> c <span class="token operator">+</span> SHARED_UNIT<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\t\t<span class="token comment">//3. 下面的代码主要是新增的一些功能，比如getReadHoldCount()方法</span>\n\t\t<span class="token comment">//返回当前获取读锁的次数</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            firstReader <span class="token operator">=</span> current<span class="token punctuation">;</span>\n            firstReaderHoldCount <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>firstReader <span class="token operator">==</span> current<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            firstReaderHoldCount<span class="token operator">++</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n            <span class="token class-name">HoldCounter</span> rh <span class="token operator">=</span> cachedHoldCounter<span class="token punctuation">;</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>rh <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> rh<span class="token punctuation">.</span>tid <span class="token operator">!=</span> <span class="token function">getThreadId</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">)</span>\n                cachedHoldCounter <span class="token operator">=</span> rh <span class="token operator">=</span> readHolds<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>rh<span class="token punctuation">.</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>\n                readHolds<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>rh<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            rh<span class="token punctuation">.</span>count<span class="token operator">++</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\t<span class="token comment">//4. 处理在第二步中CAS操作失败的自旋已经实现重入性</span>\n    <span class="token keyword">return</span> <span class="token function">fullTryAcquireShared</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>代码的逻辑请看注释，需要注意的是 <strong>当写锁被其他线程获取后，读锁获取失败</strong>，否则获取成功利用 CAS 更新同步状态。</p><p>另外，当前同步状态需要加上 SHARED_UNIT（<code>(1 &lt;&lt; SHARED_SHIFT)</code>即 0x00010000）的原因这是我们在上面所说的同步状态的高 16 位用来表示读锁被获取的次数。如果 CAS 失败或者已经获取读锁的线程再次获取读锁时，是靠 fullTryAcquireShared 方法实现的，这段代码就不展开说了，有兴趣可以看看。</p><h3 id="读锁的释放" tabindex="-1"><a class="header-anchor" href="#读锁的释放" aria-hidden="true">#</a> 读锁的释放</h3><p>读锁释放的实现主要通过方法 tryReleaseShared，源码如下，主要逻辑请看注释：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryReleaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> unused<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token class-name">Thread</span> current <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\t<span class="token comment">// 前面还是为了实现getReadHoldCount等新功能</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>firstReader <span class="token operator">==</span> current<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// assert firstReaderHoldCount &gt; 0;</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>firstReaderHoldCount <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>\n            firstReader <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n        <span class="token keyword">else</span>\n            firstReaderHoldCount<span class="token operator">--</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n        <span class="token class-name">HoldCounter</span> rh <span class="token operator">=</span> cachedHoldCounter<span class="token punctuation">;</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>rh <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> rh<span class="token punctuation">.</span>tid <span class="token operator">!=</span> <span class="token function">getThreadId</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">)</span>\n            rh <span class="token operator">=</span> readHolds<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">int</span> count <span class="token operator">=</span> rh<span class="token punctuation">.</span>count<span class="token punctuation">;</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            readHolds<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>\n                <span class="token keyword">throw</span> <span class="token function">unmatchedUnlockException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        <span class="token operator">--</span>rh<span class="token punctuation">.</span>count<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\t\t<span class="token comment">// 读锁释放 将同步状态减去读状态即可</span>\n        <span class="token keyword">int</span> nextc <span class="token operator">=</span> c <span class="token operator">-</span> SHARED_UNIT<span class="token punctuation">;</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> nextc<span class="token punctuation">)</span><span class="token punctuation">)</span>\n            <span class="token comment">// Releasing the read lock has no effect on readers,</span>\n            <span class="token comment">// but it may allow waiting writers to proceed if</span>\n            <span class="token comment">// both read and write locks are now free.</span>\n            <span class="token keyword">return</span> nextc <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="锁降级" tabindex="-1"><a class="header-anchor" href="#锁降级" aria-hidden="true">#</a> 锁降级</h2><p>读写锁支持锁降级，<strong>遵循按照获取写锁，获取读锁再释放写锁的次序，写锁能够降级成为读锁</strong>，不支持锁升级，关于锁降级下面的示例代码摘自 ReentrantWriteReadLock 源码中：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">void</span> <span class="token function">processCachedData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    rwl<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>cacheValid<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// Must release read lock before acquiring write lock</span>\n        rwl<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        rwl<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">try</span> <span class="token punctuation">{</span>\n            <span class="token comment">// Recheck state because another thread might have</span>\n            <span class="token comment">// acquired write lock and changed state before we did.</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>cacheValid<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                data <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>\n        cacheValid <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n      <span class="token comment">// Downgrade by acquiring read lock before releasing write lock</span>\n      rwl<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>\n      rwl<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Unlock write, still hold read</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token keyword">try</span> <span class="token punctuation">{</span>\n    <span class="token function">use</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>\n    rwl<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>',36),p=(0,e._)("p",null,"编辑：沉默王二，内容大部分来源以下三个开源仓库：",-1),o={href:"http://concurrent.redspider.group/",target:"_blank",rel:"noopener noreferrer"},c=(0,e.Uk)("深入浅出 Java 多线程"),l={href:"https://github.com/CL0610/Java-concurrency",target:"_blank",rel:"noopener noreferrer"},i=(0,e.Uk)("并发编程知识总结"),u={href:"https://github.com/CoderLeixiaoshuai/java-eight-part",target:"_blank",rel:"noopener noreferrer"},r=(0,e.Uk)("Java 八股文"),d=(0,e._)("img",{src:"https://cdn.jsdelivr.net/gh/thinkingme/thinkingme.github.io@master/images/xingbiaogongzhonghao.png"},null,-1),k={},v=(0,a(13860).Z)(k,[["render",function(n,s){const a=(0,e.up)("ExternalLinkIcon");return(0,e.wg)(),(0,e.iD)("div",null,[t,(0,e._)("blockquote",null,[p,(0,e._)("ul",null,[(0,e._)("li",null,[(0,e._)("a",o,[c,(0,e.Wm)(a)])]),(0,e._)("li",null,[(0,e._)("a",l,[i,(0,e.Wm)(a)])]),(0,e._)("li",null,[(0,e._)("a",u,[r,(0,e.Wm)(a)])])])]),d])}]])},13860:(n,s)=>{s.Z=(n,s)=>{const a=n.__vccOpts||n;for(const[n,e]of s)a[n]=e;return a}}}]);