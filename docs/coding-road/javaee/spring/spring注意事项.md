# spring 注意事项

## spring中同一个类的方法互相调用会导致什么问题

在Spring框架中，同一个类的方法互相调用本身并不会直接引起问题，因为这只是普通的Java方法调用。然而，当这些方法涉及Spring的**事务管理**或**AOP（面向切面编程）**时，就可能出现一些特定的问题。

### 事务管理

Spring的声明式事务管理是通过AOP代理实现的。当你从外部调用一个类的被`@Transactional`注解的方法时，Spring会通过代理来处理这个调用，确保事务按预期工作。但是，如果在同一个类中的一个方法直接调用另一个使用`@Transactional`注解的方法，这种内部调用会绕过Spring的代理，导致事务管理不会按预期工作。换句话说，内部调用不会触发事务的开始和提交，因为事务管理是通过代理加入的，而内部调用并不经过代理。

### AOP相关问题

和事务管理类似，Spring的其他AOP功能也是通过代理实现的，比如：安全检查、日志、性能监控等。如果你在相同的类中直接调用另一个方法，这个调用也会绕过Spring的代理机制，导致AOP相关的注解不会生效。

### 解决方案

解决同一个类方法间调用导致的问题，通常有以下几种方法：

1. **重构代码**：最直接的方法是将涉及事务或需要通过AOP代理增强的逻辑移动到另一个Bean中。这样，当从一个Bean调用另一个Bean的方法时，Spring可以通过代理来处理响应的功能，如事务管理、安全检查等。

2. **自我注入**：在类中注入本身的一个代理实例并通过该代理实例调用方法。这种方式可以让调用走代理，但可能会导致循环依赖问题，并不是推荐做法。

3. **使用`AopContext.currentProxy()`**：Spring允许你通过`AopContext`访问当前的代理对象，你可以通过这个代理来调用当前对象的其他方法，以触发AOP逻辑。注意，使用这种方法需要开启`<aop:aspectj-autoproxy expose-proxy="true"/>`或`@EnableAspectJAutoProxy(exposeProxy = true)`。这个方法虽然可以解决问题，但它会使代码与Spring框架的实现细节耦合，降低了代码的清晰性和可维护性。

总的来说，当你在Spring中遇到这样的需求时，最好是通过设计和架构的考虑来避免，比如通过服务层分离等，以避免这些复杂性。
